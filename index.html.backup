<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editorial SEO Tool (Beta) v1.3.1</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', Roboto, sans-serif;
            background: #fafbfc;
            min-height: 100vh;
            padding: 0;
            color: #2d3748;
            line-height: 1.6;
            font-size: 14px;
        }

        .container {
            display: flex;
            min-height: 100vh;
            max-width: 1400px;
            margin: 0 auto;
        }

        .sidebar {
            width: 280px;
            background: #ffffff;
            border-right: 1px solid #e2e8f0;
            padding: 0;
            overflow-y: auto;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.05);
        }

        .sidebar-header {
            padding: 20px 16px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-header h3 {
            margin: 0;
            color: #1a202c;
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .app-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            background: #4a5568;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 12px;
        }

        .sidebar-section {
            padding: 8px 0;
        }

        .sidebar-section h4 {
            margin: 0 0 8px 0;
            color: #718096;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 0 16px;
        }

        .nav-item {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            margin: 2px 8px;
            border-radius: 6px;
            color: #4a5568;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
        }

        .nav-item:hover {
            background: #f7fafc;
            color: #2d3748;
        }

        .nav-item.active {
            background: #edf2f7;
            color: #2b6cb0;
            border-left: 3px solid #3182ce;
        }

        .nav-item .nav-icon {
            width: 20px;
            height: 20px;
            margin-right: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .nav-tag {
            background: #e2e8f0;
            color: #718096;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: auto;
            font-weight: 500;
        }

        .project-section {
            margin-top: 24px;
        }

        .project-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px 8px;
        }

        .project-header h4 {
            margin: 0;
            color: #718096;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .project-actions {
            display: flex;
            gap: 4px;
        }

        .project-action {
            width: 20px;
            height: 20px;
            border: none;
            background: transparent;
            color: #a0aec0;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .project-action:hover {
            background: #f7fafc;
            color: #4a5568;
        }

        .project-folder {
            margin: 0;
        }

        .project-folder-header {
            display: flex;
            align-items: center;
            padding: 6px 16px;
            color: #4a5568;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 6px;
            margin: 2px 8px;
            transition: all 0.2s ease;
        }

        .project-folder-header:hover {
            background: #f7fafc;
        }

        .project-folder-icon {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            color: #a0aec0;
        }

        .project-folder-items {
            margin-left: 24px;
            margin-top: 4px;
            display: none; /* Collapsed by default */
        }

        .project-folder-header {
            cursor: pointer;
            user-select: none;
        }

        .project-folder-header:hover {
            background: #f7fafc;
        }

        .project-item {
            display: flex;
            align-items: center;
            padding: 6px 16px;
            color: #4a5568;
            font-size: 13px;
            cursor: pointer;
            border-radius: 6px;
            margin: 2px 8px;
            transition: all 0.2s ease;
        }

        .project-item:hover {
            background: #f7fafc;
            color: #2d3748;
        }

        .project-item-icon {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            color: #a0aec0;
        }




        .empty-state {
            text-align: center;
            padding: 20px;
            color: #a0aec0;
        }

        .empty-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .empty-state p {
            margin: 0;
            font-size: 12px;
        }







        /* Progress indicator animation */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Step status styles */
        [data-step].active {
            background: #dbeafe !important;
            border-color: #3b82f6 !important;
            transform: scale(1.02);
        }

        [data-step].completed {
            background: #d1fae5 !important;
            border-color: #10b981 !important;
        }

        [data-step].pending {
            background: #f8fafc !important;
            border-color: #e2e8f0 !important;
        }

        .step-indicator {
            transition: all 0.3s ease !important;
        }

        .step-text {
            transition: all 0.3s ease !important;
        }

        /* Version Info Styles */
        .version-info {
            padding: 12px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            text-align: center;
        }

        .version-number {
            font-size: 18px;
            font-weight: 600;
            color: #3b82f6;
            margin-bottom: 4px;
        }

        .version-date {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 8px;
        }

        .version-info .btn {
            width: 100%;
            font-size: 11px;
            padding: 6px 12px;
        }

        /* Client Management Styles */
        .client-select-container {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .client-select-container select {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            color: #2d3748;
        }

        .client-select-container select:focus {
            outline: none;
            border-color: #3182ce;
            box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.1);
        }

        .client-info {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-top: 12px;
            display: none;
        }

        .client-info.show {
            display: block;
        }

        .client-info h4 {
            margin: 0 0 12px 0;
            color: #2d3748;
            font-size: 16px;
        }

        .client-info-item {
            margin-bottom: 8px;
        }

        .client-info-label {
            font-weight: 600;
            color: #4a5568;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .client-info-value {
            color: #2d3748;
            font-size: 14px;
            margin-top: 2px;
        }

        /* Client Management Styles */
        .client-management-content {
            max-height: 70vh;
            overflow-y: auto;
        }

        .client-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .client-card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .client-card:hover {
            border-color: #3182ce;
            box-shadow: 0 4px 12px rgba(49, 130, 206, 0.1);
            transform: translateY(-2px);
        }

        .client-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .client-card-header h5 {
            margin: 0;
            color: #2d3748;
            font-size: 16px;
        }

        .client-card-content p {
            margin: 8px 0;
            color: #4a5568;
            font-size: 14px;
            line-height: 1.4;
        }

        .form-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e2e8f0;
        }

        /* Output Section Styles */
        .output-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid #e2e8f0;
        }

        .output-header h3 {
            margin: 0;
            color: #2d3748;
            font-size: 20px;
            font-weight: 600;
        }

        .url-input-section {
            margin-bottom: 15px;
            padding: 12px;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 6px;
        }

        .url-controls {
            display: flex;
            gap: 8px;
        }


        .screenshot-stats {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        .stat-item {
            text-align: center;
            flex: 1;
        }

        .stat-number {
            display: block;
            font-size: 1.2rem;
            font-weight: 600;
            color: #495057;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .screenshot-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .screenshot-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin-bottom: 8px;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            font-size: 0.8rem;
        }

        .screenshot-item img {
            width: 40px;
            height: 30px;
            object-fit: cover;
            border-radius: 4px;
            margin-right: 8px;
        }

        .screenshot-item-info {
            flex: 1;
            min-width: 0;
        }

        .screenshot-item-name {
            font-weight: 500;
            color: #495057;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .screenshot-item-size {
            color: #6c757d;
            font-size: 0.7rem;
            margin-bottom: 8px;
        }

        .screenshot-item-actions {
            display: flex;
            gap: 4px;
        }

        .screenshot-actions {
            display: flex;
            gap: 8px;
        }

        .quick-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 0 16px;
        }

        .client-select-container {
            padding: 0 16px;
            margin-bottom: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .client-select-container select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
            font-size: 0.875rem;
            min-height: 40px;
            box-sizing: border-box;
        }

        .client-select-container .btn {
            width: 100%;
            justify-content: center;
            padding: 8px 12px;
            min-height: 36px;
        }

        .client-info {
            padding: 0 16px;
            margin-top: 16px;
            font-size: 0.85rem;
            background: #f9fafb;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 16px 0 16px;
        }

        .client-info h4 {
            margin: 0 0 12px 0;
            font-size: 0.8rem;
            font-weight: 600;
            color: #374151;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .client-info-item {
            margin-bottom: 12px;
            padding: 8px 0;
        }

        .client-info-item:last-child {
            margin-bottom: 0;
        }

        .client-info-label {
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 4px;
            font-size: 0.8rem;
        }

        .client-info-value {
            color: #6b7280;
            font-size: 0.85rem;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .client-info-value .tone-preview {
            background: #f3f4f6;
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #3b82f6;
            margin-bottom: 8px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.8rem;
            white-space: pre-wrap;
            max-height: 120px;
            overflow: hidden;
        }

        .client-info-value .edit-tone-btn {
            font-size: 0.75rem;
            padding: 4px 8px;
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            color: #374151;
        }

        .client-info-value .edit-tone-btn:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }

        /* Version History Styles */
        .version-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .version-item {
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
            background: white;
        }

        .version-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .version-date {
            color: #6c757d;
            font-size: 0.9rem;
        }

        .version-changes {
            color: #495057;
            margin-bottom: 10px;
            font-style: italic;
        }

        .version-actions {
            display: flex;
            gap: 8px;
        }

        .comparison-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .version-panel {
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
        }

        .version-panel h4 {
            margin: 0 0 10px 0;
            color: #495057;
        }

        .version-content {
            max-height: 400px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9rem;
        }

        /* Trash Styles */
        .trash-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .trash-item {
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
            background: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .article-info h4 {
            margin: 0 0 5px 0;
            color: #495057;
        }

        .article-info p {
            margin: 0;
            color: #6c757d;
            font-size: 0.9rem;
        }

        .trash-actions {
            display: flex;
            gap: 8px;
        }

        /* Search Results Styles */
        .search-form {
            margin-bottom: 20px;
        }

        .filter-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .search-results {
            max-height: 400px;
            overflow-y: auto;
        }

        .search-result-item {
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
            background: white;
        }

        .search-result-item h4 {
            margin: 0 0 8px 0;
            color: #495057;
        }

        .search-result-item p {
            margin: 0 0 5px 0;
            color: #6c757d;
            font-size: 0.9rem;
        }

        .result-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        /* Lock Indicator */
        .lock-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #dc3545;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8rem;
        }

        /* Drag and Drop Styles */
        .sortable-item {
            cursor: move;
            transition: opacity 0.2s;
        }

        .sortable-item:hover {
            background: #f8f9fa;
        }

        .sortable-item.dragging {
            opacity: 0.5;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 0;
            border: 1px solid #888;
            border-radius: 8px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            color: #495057;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover,
        .close:focus {
            color: #000;
        }

        .modal-body {
            padding: 20px;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 0.8rem;
            border-radius: 4px;
        }


        .empty-state {
            text-align: center;
            padding: 20px;
            color: #6c757d;
            font-size: 0.8rem;
        }

        .main-content {
            flex: 1;
            background: #fafbfc;
            overflow-y: auto;
        }

        .main-header {
            background: #ffffff;
            border-bottom: 1px solid #e2e8f0;
            padding: 16px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .main-title {
            font-size: 20px;
            font-weight: 600;
            color: #1a202c;
            margin: 0;
        }

        .main-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .content-area {
            padding: 24px;
        }

        .header {
            background: #f8f9fa;
            color: #1a1a1a;
            padding: 40px;
            text-align: center;
            border-bottom: 1px solid #e0e0e0;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 8px;
            font-weight: 600;
            color: #1a1a1a;
            letter-spacing: -0.5px;
        }

        .header p {
            font-size: 16px;
            color: #666;
            font-weight: 400;
        }

        /* Tooltip styles */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 300px;
            background-color: #2c3e50;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 12px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            line-height: 1.4;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #2c3e50 transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .tooltip-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            background-color: #6c757d;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 16px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 6px;
            vertical-align: middle;
        }

        .form-container {
            padding: 32px;
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
        }

        .form-card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
            margin-bottom: 20px;
        }

        .form-card-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid #e2e8f0;
        }

        .form-card-icon {
            width: 24px;
            height: 24px;
            margin-right: 12px;
            color: #4a5568;
        }

        .form-card-title {
            font-size: 16px;
            font-weight: 600;
            color: #1a202c;
            margin: 0;
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-bottom: 24px;
        }

        .form-group {
            margin-bottom: 24px;
        }

        .form-group.full-width {
            grid-column: 1 / -1;
        }

        /* Enhanced Keyword Management Styles */
        .keyword-density-info {
            margin-top: 6px;
            color: #666;
            font-size: 12px;
        }

        .supporting-keywords-container {
            margin-bottom: 12px;
        }

        .keyword-input-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 8px;
        }

        .supporting-keyword-input {
            flex: 1;
            margin-bottom: 0;
        }

        .remove-keyword-btn {
            width: 32px;
            height: 32px;
            border: 1px solid #dc3545;
            background: #fff;
            color: #dc3545;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.2s ease;
            margin-bottom: 0;
        }

        .remove-keyword-btn:hover {
            background: #dc3545;
            color: #fff;
        }

        .add-keyword-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: background-color 0.2s ease;
            margin-bottom: 8px;
        }

        .add-keyword-btn:hover {
            background: #218838;
        }

        .add-keyword-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .keyword-actions {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .keyword-summary {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px 12px;
            margin-top: 8px;
            font-size: 12px;
            color: #495057;
        }

        .keyword-summary .primary {
            font-weight: 600;
            color: #007bff;
        }

        .keyword-summary .supporting {
            color: #6c757d;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #333;
            font-size: 14px;
        }

        input, select, textarea {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d0d0d0;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            background: #ffffff;
            color: #333;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-align: center;
        }

        .btn-primary {
            background: #3182ce;
            color: white;
        }

        .btn-primary:hover {
            background: #2c5aa0;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(49, 130, 206, 0.3);
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
            border: 1px solid #e2e8f0;
        }

        .btn-secondary:hover {
            background: #cbd5e0;
            color: #2d3748;
            transform: translateY(-1px);
        }

        .btn-success {
            background: #38a169;
            color: white;
        }

        .btn-success:hover {
            background: #2f855a;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(56, 161, 105, 0.3);
        }



        .output-section {
            margin-top: 24px;
            padding: 24px;
            background: #ffffff;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            display: none;
        }

        .output-section.show {
            display: block;
        }

        .output-text {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }

        .step-review-section {
            margin-top: 24px;
            padding: 24px;
            background: #ffffff;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            display: none;
        }

        .step-review-section.show {
            display: block;
        }

        .step-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e2e8f0;
        }

        .step-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #2d3748;
        }

        .step-number {
            background: #4f46e5;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .step-content {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            margin-bottom: 20px;
        }

        .step-textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            resize: vertical;
        }

        .step-textarea:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        /* Step Notes Styles */
        .step-notes {
            margin: 20px 0;
            padding: 20px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
        }

        .step-notes label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #374151;
        }

        .step-notes-textarea {
            width: 100%;
            min-height: 80px;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-family: inherit;
            font-size: 0.9rem;
            line-height: 1.5;
            resize: vertical;
            transition: border-color 0.2s ease;
        }

        .step-notes-textarea:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .notes-examples {
            margin-top: 8px;
            color: #6b7280;
            font-style: italic;
        }

        .btn.active {
            background: #4f46e5;
            color: white;
            border-color: #4f46e5;
        }

        .btn.active:hover {
            background: #4338ca;
            border-color: #4338ca;
        }

        .step-actions {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
        }

        .btn-secondary {
            background: #6b7280;
            color: white;
        }

        .btn-secondary:hover {
            background: #4b5563;
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(107, 114, 128, 0.3);
        }

        .btn-success {
            background: #28a745;
            color: white;
            border-color: #28a745;
        }

        .btn-success:hover {
            background: #218838;
            border-color: #1e7e34;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
            border-color: #f59e0b;
        }

        .btn-warning:hover {
            background: #d97706;
            border-color: #b45309;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
        }

        .btn-danger {
            background: #dc2626;
            color: white;
            border-color: #dc2626;
        }

        .btn-danger:hover {
            background: #b91c1c;
            border-color: #991b1b;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3);
        }

        .progress-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            gap: 10px;
        }

        .progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e2e8f0;
            transition: all 0.3s ease;
        }

        .progress-dot.active {
            background: #4f46e5;
        }

        .progress-dot.completed {
            background: #10b981;
        }

        .file-upload-section {
            background: #f8fafc;
            padding: 20px;
            border-radius: 10px;
            border: 2px dashed #cbd5e1;
            margin-bottom: 20px;
        }

        .file-upload-section:hover {
            border-color: #4f46e5;
            background: #f1f5f9;
        }

        input[type="file"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: white;
            cursor: pointer;
        }

        input[type="file"]:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .file-upload-label {
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
            display: block;
        }

        .file-upload-help {
            color: #6b7280;
            font-size: 0.875rem;
            margin-top: 5px;
        }

        .final-review-section {
            margin-top: 24px;
            padding: 24px;
            background: #ffffff;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            display: none;
        }

        .final-review-section.show {
            display: block;
        }

        .review-header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e2e8f0;
        }

        .review-header h3 {
            font-size: 2rem;
            color: #2d3748;
            margin-bottom: 10px;
        }

        .review-header p {
            color: #6b7280;
            font-size: 1.1rem;
        }

        .review-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .article-sections {
            display: grid;
            gap: 25px;
            margin-bottom: 30px;
        }

        .section-editor {
            background: white;
            border-radius: 12px;
            border: 2px solid #e2e8f0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .section-editor:hover {
            border-color: #4f46e5;
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.1);
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
        }

        .section-header h4 {
            font-size: 1.1rem;
            color: #2d3748;
            margin: 0;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.875rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #6b7280;
            color: white;
        }

        .btn-small:hover {
            background: #4b5563;
            transform: translateY(-1px);
        }

        .static-sections {
            display: block;
        }

        .static-sections.hidden {
            display: none;
        }

        .section-textarea {
            width: 100%;
            min-height: 150px;
            padding: 20px;
            border: none;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            resize: vertical;
            background: white;
        }

        .section-textarea:focus {
            outline: none;
            background: #fefefe;
        }

        .final-actions {
            padding: 20px 0;
            border-top: 2px solid #e2e8f0;
        }

        .action-group {
            margin-bottom: 25px;
            text-align: center;
        }

        .action-group:last-child {
            margin-bottom: 0;
        }

        .action-group-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #6b7280;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .action-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            align-items: center;
        }

        .approval-group {
            padding: 20px 0;
            border-top: 1px solid #e5e7eb;
            border-bottom: 1px solid #e5e7eb;
            background: #f9fafb;
            border-radius: 8px;
        }

        .data-management {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #f3f4f6;
        }

        .btn-large {
            padding: 12px 24px;
            font-size: 1.1rem;
            font-weight: 600;
            min-width: 200px;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 0.85rem;
            min-width: auto;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 30px 20px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .loading.show {
            display: block;
        }

        .floating-bee {
            position: relative;
            width: 60px;
            height: 60px;
            margin: 0 auto 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .bee-body {
            width: 30px;
            height: 20px;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            border-radius: 50%;
            position: relative;
            animation: bee-float 3s ease-in-out infinite;
        }

        .bee-stripes {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 50%;
            background: repeating-linear-gradient(
                90deg,
                #fbbf24 0px,
                #fbbf24 3px,
                #1f2937 3px,
                #1f2937 6px
            );
        }

        .bee-wings {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
        }

        .bee-wing {
            width: 8px;
            height: 12px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            animation: wing-flap 0.3s ease-in-out infinite;
        }

        .bee-wing:nth-child(1) {
            animation-delay: 0s;
        }

        .bee-wing:nth-child(2) {
            animation-delay: 0.15s;
        }

        .bee-eyes {
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 6px;
        }

        .bee-eye {
            width: 3px;
            height: 3px;
            background: #1f2937;
            border-radius: 50%;
        }

        .bee-trail {
            position: absolute;
            top: 10px;
            right: -15px;
            width: 20px;
            height: 2px;
            background: linear-gradient(90deg, transparent 0%, rgba(251, 191, 36, 0.3) 50%, transparent 100%);
            animation: trail-wiggle 2s ease-in-out infinite;
        }

        @keyframes bee-float {
            0%, 100% { 
                transform: translateY(0px) rotate(0deg); 
            }
            25% { 
                transform: translateY(-8px) rotate(-1deg); 
            }
            50% { 
                transform: translateY(-12px) rotate(0deg); 
            }
            75% { 
                transform: translateY(-8px) rotate(1deg); 
            }
        }

        @keyframes wing-flap {
            0%, 100% { 
                transform: scaleY(1) rotate(0deg); 
            }
            50% { 
                transform: scaleY(0.7) rotate(5deg); 
            }
        }

        @keyframes trail-wiggle {
            0%, 100% { 
                transform: translateX(0px) rotate(0deg); 
                opacity: 0.3;
            }
            50% { 
                transform: translateX(5px) rotate(2deg); 
                opacity: 0.6;
            }
        }

        .loading-text {
            font-size: 16px;
            font-weight: 500;
            color: #4a5568;
            margin: 0;
            position: relative;
        }

        .loading-text::after {
            content: '';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% {
                content: '';
            }
            40% {
                content: '.';
            }
            60% {
                content: '..';
            }
            80%, 100% {
                content: '...';
            }
        }

        /* Review button loading states */
        .btn.loading {
            position: relative;
            color: transparent;
            pointer-events: none;
            opacity: 0.7;
        }

        .btn.loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .btn.loading::before {
            content: attr(data-loading-text);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #374151;
            font-size: 14px;
            white-space: nowrap;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* Whimsical leaf animation for reviews */
        .review-loading {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            padding: 24px 32px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            text-align: center;
            backdrop-filter: blur(8px);
        }

        .review-loading.show {
            display: block;
        }

        .leaf-container {
            position: relative;
            width: 80px;
            height: 60px;
            margin: 0 auto 16px;
        }

        .floating-leaf {
            position: absolute;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border-radius: 50% 0 50% 0;
            transform-origin: center;
            animation: leaf-float 3s ease-in-out infinite;
        }

        .floating-leaf:nth-child(1) {
            top: 10px;
            left: 30px;
            animation-delay: 0s;
            animation-duration: 2.8s;
        }

        .floating-leaf:nth-child(2) {
            top: 25px;
            left: 45px;
            animation-delay: 0.5s;
            animation-duration: 3.2s;
            transform: scale(0.8);
        }

        .floating-leaf:nth-child(3) {
            top: 35px;
            left: 20px;
            animation-delay: 1s;
            animation-duration: 2.5s;
            transform: scale(0.6);
        }

        .floating-leaf:nth-child(4) {
            top: 15px;
            left: 50px;
            animation-delay: 1.5s;
            animation-duration: 3.5s;
            transform: scale(0.7);
        }

        @keyframes leaf-float {
            0% {
                transform: translateY(0px) rotate(0deg) scale(1);
                opacity: 0.7;
            }
            25% {
                transform: translateY(-8px) rotate(5deg) scale(1.1);
                opacity: 1;
            }
            50% {
                transform: translateY(-12px) rotate(-3deg) scale(0.9);
                opacity: 0.8;
            }
            75% {
                transform: translateY(-6px) rotate(2deg) scale(1.05);
                opacity: 0.9;
            }
            100% {
                transform: translateY(0px) rotate(0deg) scale(1);
                opacity: 0.7;
            }
        }

        .review-loading-text {
            font-size: 0.9rem;
            color: #6b7280;
            font-weight: 500;
            margin: 0;
        }

        /* Citation Progress Modal */
        .citation-progress {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            z-index: 1001;
            text-align: center;
            backdrop-filter: blur(8px);
            min-width: 400px;
            max-width: 500px;
        }

        .citation-progress.show {
            display: block;
        }

        .citation-progress-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 8px;
        }

        .citation-progress-subtitle {
            font-size: 0.9rem;
            color: #6b7280;
            margin-bottom: 24px;
        }

        .citation-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 16px;
            background: #f8fafc;
            border-radius: 8px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: #3b82f6;
            display: block;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #6b7280;
            margin-top: 4px;
        }

        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 16px;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #1d4ed8);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .current-section {
            font-size: 0.9rem;
            color: #374151;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .time-estimate {
            font-size: 0.8rem;
            color: #6b7280;
        }

        /* Confetti styles */
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #f39c12;
            animation: confetti-fall 3s linear infinite;
            z-index: 9999;
        }

        .confetti:nth-child(odd) {
            background: #e74c3c;
            animation-delay: -0.5s;
        }

        .confetti:nth-child(even) {
            background: #3498db;
            animation-delay: -1s;
        }

        .confetti:nth-child(3n) {
            background: #2ecc71;
            animation-delay: -1.5s;
        }

        .confetti:nth-child(4n) {
            background: #9b59b6;
            animation-delay: -2s;
        }

        .confetti:nth-child(5n) {
            background: #f1c40f;
            animation-delay: -2.5s;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* Steaming Coffee Cup Animation */
        .coffee-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            border: 1px solid #e5e7eb;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            text-align: center;
            backdrop-filter: blur(12px);
            animation: coffeeModalSlideIn 0.6s ease-out;
        }

        .coffee-cup {
            position: relative;
            width: 60px;
            height: 60px;
            margin: 0 auto 20px;
            background: #8B4513;
            border-radius: 0 0 30px 30px;
            border: 2px solid #654321;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            animation: coffeeFloat 3s ease-in-out infinite;
        }

        .coffee-cup::before {
            content: '';
            position: absolute;
            top: -6px;
            right: -12px;
            width: 15px;
            height: 20px;
            background: #8B4513;
            border-radius: 0 10px 10px 0;
            border: 2px solid #654321;
            border-left: none;
        }

        .coffee-liquid {
            position: absolute;
            top: 3px;
            left: 3px;
            right: 3px;
            height: 15px;
            background: #4A2C2A;
            border-radius: 0 0 25px 25px;
        }

        .steam {
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 30px;
            background: linear-gradient(to top, 
                rgba(200, 200, 200, 0.8) 0%, 
                rgba(200, 200, 200, 0.4) 50%, 
                transparent 100%);
            border-radius: 2px;
            animation: steamRise 2s ease-in-out infinite;
        }

        .steam:nth-child(2) {
            left: 45%;
            animation-delay: 0.3s;
            animation-duration: 2.2s;
        }

        .steam:nth-child(3) {
            left: 55%;
            animation-delay: 0.6s;
            animation-duration: 1.8s;
        }

        .coffee-message {
            font-size: 1.1rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
            animation: messagePulse 2s ease-in-out infinite;
        }

        .coffee-submessage {
            font-size: 0.9rem;
            color: #6b7280;
            margin-bottom: 20px;
        }

        .coffee-dismiss {
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .coffee-dismiss:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        /* Animations */
        @keyframes coffeeModalSlideIn {
            from {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        @keyframes steamRise {
            0% {
                transform: translateX(-50%) translateY(0) scaleY(1);
                opacity: 0.8;
            }
            50% {
                transform: translateX(-50%) translateY(-10px) scaleY(1.2);
                opacity: 0.6;
            }
            100% {
                transform: translateX(-50%) translateY(-20px) scaleY(0.8);
                opacity: 0;
            }
        }


        @keyframes messagePulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        @keyframes coffeeFloat {
            0%, 100% {
                transform: translateY(0) rotate(0deg);
            }
            25% {
                transform: translateY(-5px) rotate(1deg);
            }
            75% {
                transform: translateY(-3px) rotate(-1deg);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="sidebar-header">
                <h3>
                    <div class="app-icon">E</div>
                    Editorial SEO
                </h3>
            </div>
            
            <div class="sidebar-section">
                <h4>NAVIGATION</h4>
                <div class="nav-item active" onclick="showContentGeneration(event)">
                    <div class="nav-icon"></div>
                    Content Generation
                    <div class="nav-tag">ACTIVE</div>
                </div>
                <div class="nav-item" onclick="showArticleManagement(event)">
                    <div class="nav-icon"></div>
                    Article Management
                </div>
            </div>
            
            
            
            <div class="sidebar-section">
                <h4>TOOLS</h4>
                <div class="nav-item" onclick="showScreenshotModal()">
                    <div class="nav-icon"></div>
                    Screenshots
                </div>
            </div>
            
            <div class="sidebar-section">
                <h4>CLIENT</h4>
                <div class="client-select-container">
                    <select id="clientSelect" required onchange="loadClientData()">
                        <option value="">Select a client...</option>
                        <option value="sandbox"> Sandbox (Testing Mode)</option>
                        <option value="11x">11x</option>
                        <option value="abstract-api">Abstract API</option>
                        <option value="beacons">Beacons</option>
                        <option value="benny">Benny</option>
                        <option value="clay">Clay</option>
                        <option value="lightyear">Lightyear</option>
                        <option value="mobbin">Mobbin</option>
                        <option value="output">Output</option>
                        <option value="rho">Rho</option>
                        <option value="onesafe">OneSafe</option>
                        <option value="openart">Openart</option>
                        <option value="portrait-care">Portrait Care</option>
                        <option value="prospect">Prospect</option>
                        <option value="viva">Viva</option>
                        <option value="creatify">Creatify</option>
                        <option value="flodesk">Flodesk</option>
                        <option value="golden-gate-legal">Golden Gate Legal</option>
                        <option value="kudos">Kudos</option>
                        <option value="lightspark">Lightspark</option>
                    </select>
                    <button type="button" class="btn btn-small btn-secondary" onclick="showClientManagement()" title="Manage clients">
                        <span class="btn-icon"></span>
                        Manage
                    </button>
                </div>
                <div class="client-info" id="clientInfo">
                    <h4 id="clientInfoTitle">Client Information</h4>
                    <div class="client-info-item">
                        <div class="client-info-label">Tone & Voice</div>
                        <div class="client-info-value" id="clientToneInfo">No tone guidelines set</div>
                    </div>
                    <div class="client-info-item">
                        <div class="client-info-label">AI Artifacts to Avoid</div>
                        <div class="client-info-value" id="clientArtifactsInfo">Using default list</div>
                    </div>
                    <div class="client-info-item">
                        <div class="client-info-label">Last Updated</div>
                        <div class="client-info-value" id="clientLastUpdated">Never</div>
                    </div>
                </div>
            </div>
            
            <div class="sidebar-section">
                <h4>SETTINGS</h4>
                <div class="nav-item" onclick="showSettings()">
                    <div class="nav-icon"></div>
                    Settings
                </div>
            </div>
            
            <div class="sidebar-section">
                <h4>Article Management</h4>
                <div class="quick-actions">
                    <button type="button" class="btn btn-small" onclick="showSavedArticles()" title="Load a previously saved article">Load Article</button>
                    <button type="button" class="btn btn-small" onclick="showArticleSearch()" title="Search and filter articles">Search Articles</button>
                    <button type="button" class="btn btn-small" onclick="showTrash()" title="View deleted articles">Trash</button>
                </div>
            </div>
            
            
            <div class="sidebar-section">
                <h4>Client Memory</h4>
                <div class="quick-actions">
                    <button type="button" class="btn btn-small" onclick="showClientMemory()" title="View client memory data">View Memory</button>
                </div>
            </div>
            
            <div class="sidebar-section">
                <h4>VERSION</h4>
                <div class="version-info">
                    <div class="version-number">v1.3.1</div>
                    <div class="version-date">Jan 27, 2025</div>
                    <button class="btn btn-small" onclick="showVersionInfo()">Version Info</button>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="main-header">
                <h1 class="main-title">Content Generation</h1>
            </div>

            <div class="content-area">
                <div class="form-container">
            <form id="workflowForm">
                <div class="form-grid">
                    <div class="form-group">
                        <label for="topic">Topic
                            <span class="tooltip">
                                <span class="tooltip-icon">?</span>
                                <span class="tooltiptext">The main subject or theme of your article. Be specific and descriptive to help the AI generate more targeted content.</span>
                            </span>
                        </label>
                        <input type="text" id="topic" placeholder="Enter your article topic..." required>
                    </div>

                    <div class="form-group">
                        <label for="primaryKeyword">Primary Keyword
                            <span class="tooltip">
                                <span class="tooltip-icon">?</span>
                                <span class="tooltiptext">The main SEO keyword you want to target. This will be naturally incorporated 3-5 times throughout the article to improve search rankings.</span>
                            </span>
                        </label>
                        <input type="text" id="primaryKeyword" placeholder="Enter your primary keyword..." required>
                        <div class="keyword-density-info">
                            <small>Target density: 3-5x throughout the article</small>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Supporting Keywords
                            <span class="tooltip">
                                <span class="tooltip-icon">?</span>
                                <span class="tooltiptext">Additional keywords to naturally incorporate 1-2 times each. These help with long-tail SEO and topic relevance.</span>
                            </span>
                        </label>
                        <div class="supporting-keywords-container">
                            <div class="keyword-input-row">
                                <input type="text" class="supporting-keyword-input" placeholder="Supporting keyword 1..." maxlength="50">
                                <button type="button" class="remove-keyword-btn" onclick="removeSupportingKeyword(this)" style="display: none;"></button>
                            </div>
                            <div class="keyword-input-row">
                                <input type="text" class="supporting-keyword-input" placeholder="Supporting keyword 2..." maxlength="50">
                                <button type="button" class="remove-keyword-btn" onclick="removeSupportingKeyword(this)" style="display: none;"></button>
                            </div>
                            <div class="keyword-input-row">
                                <input type="text" class="supporting-keyword-input" placeholder="Supporting keyword 3..." maxlength="50">
                                <button type="button" class="remove-keyword-btn" onclick="removeSupportingKeyword(this)" style="display: none;"></button>
                            </div>
                        </div>
                        <div class="keyword-actions">
                            <button type="button" class="add-keyword-btn" onclick="addSupportingKeyword()">+ Add Supporting Keyword</button>
                            <div class="keyword-density-info">
                                <small>Target density: 1-2x each throughout the article (max 9 keywords)</small>
                            </div>
                        </div>
                        <div class="keyword-summary" id="keywordSummary" style="display: none;"></div>
                    </div>

                    <div class="form-group">
                        <label for="articleType">Article Type
                            <span class="tooltip">
                                <span class="tooltip-icon">?</span>
                                <span class="tooltiptext">Choose between a general article (10-step process) or a list-based article (2-step process with company recommendations).</span>
                            </span>
                        </label>
                        <select id="articleType" required>
                            <option value="general">General Article</option>
                            <option value="list-based">List-based Article</option>
                        </select>
                    </div>


                    <div class="form-group">
                        <label for="context">Additional Context (Optional)
                            <span class="tooltip">
                                <span class="tooltip-icon">?</span>
                                <span class="tooltiptext">Provide any specific requirements, constraints, or additional context that should guide the content generation. This helps the AI create more targeted content.</span>
                            </span>
                        </label>
                        <textarea id="context" placeholder="Any additional context or constraints"></textarea>
                    </div>
                    




                </div>

                <button type="button" class="btn" onclick="executeCSVWorkflow()">Generate Article</button>
            </form>
            </div>

            <div class="loading" id="loading">
                <div class="floating-bee">
                    <div class="bee-body">
                        <div class="bee-stripes"></div>
                        <div class="bee-wings">
                            <div class="bee-wing"></div>
                            <div class="bee-wing"></div>
                        </div>
                        <div class="bee-eyes">
                            <div class="bee-eye"></div>
                            <div class="bee-eye"></div>
                        </div>
                        <div class="bee-trail"></div>
                    </div>
                </div>
                <p class="loading-text" id="loadingText">Buzzing through your article</p>
            </div>

            <!-- Whimsical Leaf Loading Animation -->
            <div class="review-loading" id="reviewLoading">
                <div class="leaf-container">
                    <div class="floating-leaf"></div>
                    <div class="floating-leaf"></div>
                    <div class="floating-leaf"></div>
                    <div class="floating-leaf"></div>
                </div>
                <p class="review-loading-text" id="reviewLoadingText">Reviewing your content...</p>
            </div>

            <!-- Citation Progress Modal -->
            <div class="citation-progress" id="citationProgress">
                <div class="citation-progress-title">Researching Citations</div>
                <div class="citation-progress-subtitle">Finding and validating sources for your claims</div>
                
                <div class="citation-stats">
                    <div class="stat-item">
                        <span class="stat-number" id="totalClaims">0</span>
                        <div class="stat-label">Total Claims</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" id="completedClaims">0</span>
                        <div class="stat-label">Completed</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" id="foundCitations">0</span>
                        <div class="stat-label">Citations Found</div>
                    </div>
                </div>

                <div class="progress-bar-container">
                    <div class="progress-bar-fill" id="citationProgressBar"></div>
                </div>

                <div class="current-section" id="currentSection">Starting research...</div>
                <div class="time-estimate" id="timeEstimate">Calculating time remaining...</div>
            </div>

            <!-- Coffee Break Modal -->
            <div class="coffee-modal" id="coffeeModal" style="display: none;">
                <div class="coffee-cup">
                    <div class="coffee-liquid"></div>
                    <div class="steam"></div>
                    <div class="steam"></div>
                    <div class="steam"></div>
                </div>
                <div class="coffee-message">Grab a coffee. This may take a little!</div>
                <div class="coffee-submessage">Deep Research is running in the background. You can safely close this tab and return later.</div>
                <div class="coffee-progress" id="coffeeProgress" style="margin: 15px 0; font-size: 0.9rem; color: #6b7280;">
                    <div>Researching <span id="coffeeCurrentSection">citations</span>...</div>
                    <div style="margin-top: 5px; font-size: 0.8rem;">This process can take up to 30 minutes</div>
                </div>
                <button class="coffee-dismiss" onclick="hideCoffeeModal()">Got it!</button>
            </div>

            <div class="step-review-section" id="stepReviewSection">
                <div class="step-header">
                    <div class="step-title" id="stepTitle">Step Review</div>
                    <div class="step-number" id="stepNumber">1/10</div>
                </div>
                
                <div class="progress-indicator" id="progressIndicator">
                    <div class="progress-dot" data-step="1"></div>
                    <div class="progress-dot" data-step="2"></div>
                    <div class="progress-dot" data-step="3"></div>
                    <div class="progress-dot" data-step="4"></div>
                    <div class="progress-dot" data-step="5"></div>
                    <div class="progress-dot" data-step="6"></div>
                    <div class="progress-dot" data-step="7"></div>
                    <div class="progress-dot" data-step="8"></div>
                    <div class="progress-dot" data-step="9"></div>
                    <div class="progress-dot" data-step="10"></div>
                </div>

                <div class="step-content">
                    <label for="stepContentTextarea"><strong>Review and Edit Content:</strong></label>
                    <textarea id="stepContentTextarea" class="step-textarea" placeholder="Content will appear here..."></textarea>
                </div>

                <div class="step-notes" id="stepNotesSection" style="display: none;">
                    <label for="stepNotesTextarea"><strong>Add Notes for Regeneration (Optional):</strong></label>
                    <textarea id="stepNotesTextarea" class="step-notes-textarea" placeholder="Add specific instructions for how you'd like this content regenerated..."></textarea>
                    <div class="notes-examples">
                        <small>Examples: "Make it more technical", "Add more examples", "Focus on beginners", "Include more statistics"</small>
                    </div>
                </div>

                <div class="step-actions">
                    <button type="button" class="btn btn-secondary" id="regenerateStepBtn" onclick="regenerateCurrentStep()">Regenerate</button>
                    <button type="button" class="btn btn-outline" id="addNotesBtn" onclick="toggleStepNotes()"> Add Notes</button>
                    <button type="button" class="btn btn-success" id="approveStepBtn" onclick="approveCurrentStep()"> Approve & Continue</button>
                </div>
            </div>

            <div class="final-review-section" id="finalReviewSection">
                <div class="review-header">
                    <h3>Final Article Review
                        <span class="tooltip">
                            <span class="tooltip-icon">?</span>
                            <span class="tooltiptext">Review and edit each section of your generated article. You can regenerate individual sections with specific feedback or make manual edits before final approval.</span>
                        </span>
                    </h3>
                </div>

                <div class="review-controls">
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button type="button" class="btn btn-secondary" onclick="regenerateEntireArticle()">Regenerate Entire Article</button>
                        <button type="button" class="btn btn-success" onclick="approveFinalArticle()">Approve Final Article</button>
                    </div>
                </div>

                <div class="article-sections">
                    <div class="section-editor" data-section="title">
                        <div class="section-header">
                            <h4>Title</h4>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="text" id="titleFeedback" placeholder="What should be revised?" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 0.8rem; width: 200px;">
                                <button type="button" class="btn-small" onclick="regenerateSection('title')">Regenerate</button>
                            </div>
                        </div>
                        <textarea class="section-textarea" id="titleEditor" placeholder="Article title will appear here..."></textarea>
                    </div>

                    <div class="section-editor" data-section="introduction">
                        <div class="section-header">
                            <h4>Introduction</h4>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="text" id="introductionFeedback" placeholder="What should be revised?" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 0.8rem; width: 200px;">
                                <button type="button" class="btn-small" onclick="regenerateSection('introduction')">Regenerate</button>
                            </div>
                        </div>
                        <textarea class="section-textarea" id="introductionEditor" placeholder="Introduction will appear here..."></textarea>
                    </div>

                    <!-- Static sections for general articles only -->
                    <div id="staticSections" class="static-sections">
                        <div class="section-editor" data-section="section1">
                            <div class="section-header">
                                <h4>Section 1</h4>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <input type="text" id="section1Feedback" placeholder="What should be revised?" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 0.8rem; width: 200px;">
                                    <button type="button" class="btn-small" onclick="regenerateSection('section1')">Regenerate</button>
                                </div>
                            </div>
                            <textarea class="section-textarea" id="section1Editor" placeholder="Section 1 content will appear here..."></textarea>
                        </div>

                        <div class="section-editor" data-section="section2">
                            <div class="section-header">
                                <h4>Section 2</h4>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <input type="text" id="section2Feedback" placeholder="What should be revised?" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 0.8rem; width: 200px;">
                                    <button type="button" class="btn-small" onclick="regenerateSection('section2')">Regenerate</button>
                                </div>
                            </div>
                            <textarea class="section-textarea" id="section2Editor" placeholder="Section 2 content will appear here..."></textarea>
                        </div>

                        <div class="section-editor" data-section="section3">
                            <div class="section-header">
                                <h4>Section 3</h4>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <input type="text" id="section3Feedback" placeholder="What should be revised?" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 0.8rem; width: 200px;">
                                    <button type="button" class="btn-small" onclick="regenerateSection('section3')">Regenerate</button>
                                </div>
                            </div>
                            <textarea class="section-textarea" id="section3Editor" placeholder="Section 3 content will appear here..."></textarea>
                        </div>

                        <div class="section-editor" data-section="section4">
                            <div class="section-header">
                                <h4>Section 4</h4>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <input type="text" id="section4Feedback" placeholder="What should be revised?" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 0.8rem; width: 200px;">
                                    <button type="button" class="btn-small" onclick="regenerateSection('section4')">Regenerate</button>
                                </div>
                            </div>
                            <textarea class="section-textarea" id="section4Editor" placeholder="Section 4 content will appear here..."></textarea>
                        </div>

                        <div class="section-editor" data-section="section5">
                            <div class="section-header">
                                <h4>Section 5</h4>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <input type="text" id="section5Feedback" placeholder="What should be revised?" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 0.8rem; width: 200px;">
                                    <button type="button" class="btn-small" onclick="regenerateSection('section5')">Regenerate</button>
                                </div>
                            </div>
                            <textarea class="section-textarea" id="section5Editor" placeholder="Section 5 content will appear here..."></textarea>
                        </div>

                        <div class="section-editor" data-section="section6">
                            <div class="section-header">
                                <h4>Section 6</h4>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <input type="text" id="section6Feedback" placeholder="What should be revised?" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 0.8rem; width: 200px;">
                                    <button type="button" class="btn-small" onclick="regenerateSection('section6')">Regenerate</button>
                                </div>
                            </div>
                            <textarea class="section-textarea" id="section6Editor" placeholder="Section 6 content will appear here..."></textarea>
                        </div>
                    </div>

                    <!-- Dynamic sections will be generated here -->
                    <div id="dynamicSections"></div>

                    <div class="section-editor" data-section="conclusion">
                        <div class="section-header">
                            <h4> Conclusion</h4>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="text" id="conclusionFeedback" placeholder="What should be revised?" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 0.8rem; width: 200px;">
                                <button type="button" class="btn-small" onclick="regenerateSection('conclusion')">Regenerate</button>
                            </div>
                        </div>
                        <textarea class="section-textarea" id="conclusionEditor" placeholder="Conclusion will appear here..."></textarea>
                    </div>
                </div>

                <div class="final-actions">
                    <!-- Review Section -->
                    <div class="action-group">
                        <h4 class="action-group-title">Review & Quality</h4>
                        <div class="action-buttons">
                            <button type="button" id="grammarReviewBtn" class="btn btn-secondary" onclick="reviewGrammar()" title="Review grammar and writing style">Grammar</button>
                            <button type="button" id="toneReviewBtn" class="btn btn-secondary" onclick="reviewTone()" title="Check tone and voice alignment">Tone</button>
                            <button type="button" id="citationsReviewBtn" class="btn btn-secondary" onclick="reviewCitations()" title="Verify facts and citations">Citations</button>
                            <button type="button" id="aiArtifactsReviewBtn" class="btn btn-secondary" onclick="reviewAIArtifacts()" title="Scan for AI patterns">AI Artifacts</button>
                        </div>
                    </div>

                    <!-- Export & Save Section -->
                    <div class="action-group">
                        <h4 class="action-group-title">Export & Save</h4>
                        <div class="action-buttons">
                            <button type="button" class="btn btn-secondary" onclick="exportToMarkdown()" title="Download as Markdown">Export Markdown</button>
                            <button type="button" class="btn btn-secondary" onclick="exportToGoogleDocs()" title="Open in Google Docs">Export to Docs</button>
                            <button type="button" class="btn btn-secondary" onclick="saveCurrentArticle()" title="Save current progress">Save Draft</button>
                        </div>
                    </div>

                    <!-- Final Approval -->
                    <div class="action-group approval-group">
                        <button type="button" class="btn btn-success btn-large" onclick="approveFinalArticle()" title="Finalize and display the completed article"> Approve Final Article</button>
                    </div>

                    <!-- Data Management -->
                    <div class="action-group data-management">
                        <h4 class="action-group-title">Data Management</h4>
                        <div class="action-buttons">
                            <button type="button" class="btn btn-warning btn-small" onclick="clearSavedArticles()" title="Clear all saved articles">Clear Articles</button>
                            <button type="button" class="btn btn-warning btn-small" onclick="clearClientMemory()" title="Clear client memory">Clear Memory</button>
                            <button type="button" class="btn btn-danger btn-small" onclick="clearAllData()" title="Clear all data">Clear All</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="output-section" id="outputSection">
                <div class="output-header">
                    <h3>Final Article</h3>
                    <button type="button" class="btn btn-secondary" onclick="showForm()" title="Return to form">
                        <span class="btn-icon"></span>
                        Back to Form
                    </button>
                </div>
                <div class="output-text" id="outputText"></div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Settings</h3>
                <span class="close" onclick="closeSettings()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="settingsApiKey">OpenAI API Key
                        <span class="tooltip">
                            <span class="tooltip-icon">?</span>
                            <span class="tooltiptext">Your OpenAI API key for content generation. This is used for all AI-powered features in the application.</span>
                        </span>
                    </label>
                    <input type="password" id="settingsApiKey" placeholder="sk-..." value="" required>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-primary" onclick="saveSettings()">Save Settings</button>
                    <button type="button" class="btn btn-secondary" onclick="closeSettings()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables for step-by-step workflow
        let currentStep = 0;
        let generatedContent = {};
        let previousSummary = '';
        let workflowConfig = {};
        let currentArticleId = null;
        
        // Enhanced Keyword Management
        let supportingKeywords = [];
        const maxSupportingKeywords = 9;

        // Keyword management functions
        function addSupportingKeyword() {
            if (supportingKeywords.length >= maxSupportingKeywords) {
                alert(`Maximum of ${maxSupportingKeywords} supporting keywords allowed`);
                return;
            }

            const container = document.querySelector('.supporting-keywords-container');
            const newRow = document.createElement('div');
            newRow.className = 'keyword-input-row';
            newRow.innerHTML = `
                <input type="text" class="supporting-keyword-input" placeholder="Supporting keyword ${supportingKeywords.length + 1}..." maxlength="50">
                <button type="button" class="remove-keyword-btn" onclick="removeSupportingKeyword(this)"></button>
            `;
            container.appendChild(newRow);
            
            supportingKeywords.push('');
            updateKeywordSummary();
            updateAddButtonState();
        }

        function removeSupportingKeyword(button) {
            const row = button.parentElement;
            const container = document.querySelector('.supporting-keywords-container');
            const index = Array.from(container.children).indexOf(row);
            
            if (index > -1) {
                supportingKeywords.splice(index, 1);
                container.removeChild(row);
                updateKeywordSummary();
                updateAddButtonState();
            }
        }

        function updateSupportingKeywords() {
            const inputs = document.querySelectorAll('.supporting-keyword-input');
            supportingKeywords = Array.from(inputs).map(input => input.value.trim()).filter(keyword => keyword);
            updateKeywordSummary();
            updateAddButtonState();
        }

        function updateKeywordSummary() {
            const primaryKeyword = document.getElementById('primaryKeyword').value.trim();
            const summary = document.getElementById('keywordSummary');
            
            if (!primaryKeyword && supportingKeywords.length === 0) {
                summary.style.display = 'none';
                return;
            }

            let summaryText = '';
            if (primaryKeyword) {
                summaryText += `<span class="primary">Primary: "${primaryKeyword}" (3-5x)</span>`;
            }
            
            if (supportingKeywords.length > 0) {
                if (summaryText) summaryText += '<br>';
                summaryText += `<span class="supporting">Supporting: ${supportingKeywords.map(k => `"${k}"`).join(', ')} (1-2x each)</span>`;
            }
            
            summary.innerHTML = summaryText;
            summary.style.display = 'block';
        }

        function updateAddButtonState() {
            const addButton = document.querySelector('.add-keyword-btn');
            addButton.disabled = supportingKeywords.length >= maxSupportingKeywords;
        }

        function getAllKeywords() {
            const primaryKeyword = document.getElementById('primaryKeyword').value.trim();
            return {
                primary: primaryKeyword,
                supporting: supportingKeywords.filter(k => k)
            };
        }

        function getKeywordPrompt() {
            const keywords = getAllKeywords();
            let prompt = '';
            
            if (keywords.primary || keywords.supporting.length > 0) {
                prompt += `\n## KEYWORD INTEGRATION REQUIREMENTS:\n`;
                
                if (keywords.primary) {
                    prompt += `PRIMARY KEYWORD: "${keywords.primary}"\n`;
                    prompt += `- Use EXACTLY 3-5 times throughout the entire article (not per section)\n`;
                    prompt += `- Include in title, headings, and body content\n`;
                    prompt += `- Use natural variations and synonyms when appropriate\n\n`;
                }
                
                if (keywords.supporting.length > 0) {
                    prompt += `SUPPORTING KEYWORDS: ${keywords.supporting.map(k => `"${k}"`).join(', ')}\n`;
                    prompt += `- Use each supporting keyword EXACTLY 1-2 times throughout the entire article\n`;
                    prompt += `- Distribute across different sections naturally\n`;
                    prompt += `- Prioritize relevance to content context\n\n`;
                }
                
                prompt += `IMPORTANT: These are EXACT target counts, not maximums. Do not exceed these numbers. Focus on natural integration that enhances readability.`;
            }
            
            return prompt;
        }

        // Add event listeners for keyword inputs
        document.addEventListener('DOMContentLoaded', function() {
            // Primary keyword input listener
            const primaryKeywordInput = document.getElementById('primaryKeyword');
            if (primaryKeywordInput) {
                primaryKeywordInput.addEventListener('input', updateKeywordSummary);
            }

            // Supporting keyword inputs listeners
            document.addEventListener('input', function(e) {
                if (e.target.classList.contains('supporting-keyword-input')) {
                    updateSupportingKeywords();
                }
            });
        });

        // Performance optimization: Content cache for reviews
        let contentCache = {
            lastContentHash: null,
            lastReviewResults: {}
        };

        
        // Generate a simple hash for content caching
        function generateContentHash(sections) {
            const contentString = sections.map(s => `${s.title}:${s.content}`).join('|');
            let hash = 0;
            for (let i = 0; i < contentString.length; i++) {
                const char = contentString.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash.toString();
        }
        
        // Check if content has changed since last review
        function hasContentChanged(sections) {
            const currentHash = generateContentHash(sections);
            return currentHash !== contentCache.lastContentHash;
        }
        
        // Update content cache
        function updateContentCache(sections, reviewType, result) {
            const currentHash = generateContentHash(sections);
            contentCache.lastContentHash = currentHash;
            contentCache.lastReviewResults[reviewType] = result;
        }
        
        // Get cached review result
        function getCachedReview(reviewType) {
            return contentCache.lastReviewResults[reviewType] || null;
        }

        // Client Management System
        let CLIENT_DATA = {
            'sandbox': {
                name: 'Sandbox',
                displayName: ' Sandbox (Testing Mode)',
                tone: 'Professional, clear, and informative. Use a neutral, helpful tone suitable for testing and development.',
                aiArtifacts: 'Use default AI artifacts list for testing purposes.',
                lastUpdated: new Date().toISOString()
            },
            '11x': {
                name: '11x',
                displayName: '11x',
                tone: 'Professional, authoritative, data-driven, technical but accessible',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'abstract-api': {
                name: 'Abstract API',
                displayName: 'Abstract API',
                tone: 'Technical, developer-focused, precise, and solution-oriented',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'beacons': {
                name: 'Beacons',
                displayName: 'Beacons',
                tone: 'Friendly, approachable, and community-focused',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'benny': {
                name: 'Benny',
                displayName: 'Benny',
                tone: 'Personal, conversational, and authentic',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'clay': {
                name: 'Clay',
                displayName: 'Clay',
                tone: 'Professional, modern, and growth-focused',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'lightyear': {
                name: 'Lightyear',
                displayName: 'Lightyear',
                tone: 'Innovative, forward-thinking, and aspirational',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'mobbin': {
                name: 'Mobbin',
                displayName: 'Mobbin',
                tone: 'Design-focused, creative, and user-centric',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'output': {
                name: 'Output',
                displayName: 'Output',
                tone: 'Direct, results-oriented, and performance-focused',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'rho': {
                name: 'Rho',
                displayName: 'Rho',
                tone: 'Financial, trustworthy, and professional',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'onesafe': {
                name: 'OneSafe',
                displayName: 'OneSafe',
                tone: 'Security-focused, reliable, and protective',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'openart': {
                name: 'Openart',
                displayName: 'Openart',
                tone: 'Creative, artistic, and inspiring',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'portrait-care': {
                name: 'Portrait Care',
                displayName: 'Portrait Care',
                tone: 'Caring, empathetic, and health-focused',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'prospect': {
                name: 'Prospect',
                displayName: 'Prospect',
                tone: 'Sales-focused, persuasive, and conversion-oriented',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'viva': {
                name: 'Viva',
                displayName: 'Viva',
                tone: 'Energetic, vibrant, and life-affirming',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'creatify': {
                name: 'Creatify',
                displayName: 'Creatify',
                tone: 'Creative, innovative, and maker-focused',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'flodesk': {
                name: 'Flodesk',
                displayName: 'Flodesk',
                tone: 'Email marketing, design-focused, and user-friendly',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'golden-gate-legal': {
                name: 'Golden Gate Legal',
                displayName: 'Golden Gate Legal',
                tone: 'Legal, authoritative, and professional',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'kudos': {
                name: 'Kudos',
                displayName: 'Kudos',
                tone: 'Recognition-focused, positive, and celebratory',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            },
            'lightspark': {
                name: 'Lightspark',
                displayName: 'Lightspark',
                tone: 'Innovative, bright, and forward-thinking',
                aiArtifacts: 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            }
        };

        // Load client data from localStorage on page load
        function loadClientDataFromStorage() {
            const savedClientData = localStorage.getItem('clientData');
            if (savedClientData) {
                try {
                    const parsedData = JSON.parse(savedClientData);
                    // Merge with default data, preserving defaults for any missing clients
                    CLIENT_DATA = { ...CLIENT_DATA, ...parsedData };
                } catch (e) {
                    console.error('Error loading client data from localStorage:', e);
                }
            }
        }

        // Populate client dropdown dynamically
        function populateClientDropdown() {
            const clientSelect = document.getElementById('clientSelect');
            if (!clientSelect) return;

            // Clear existing options except the first one
            clientSelect.innerHTML = '<option value="">Select a client...</option>';

            // Add all clients from CLIENT_DATA
            Object.entries(CLIENT_DATA).forEach(([clientId, client]) => {
                const option = document.createElement('option');
                option.value = clientId;
                option.textContent = client.displayName;
                clientSelect.appendChild(option);
            });
        }

        // Hardcoded AI Artifacts to Avoid - Codified system
        const CODIFIED_AI_ARTIFACTS = `AI Artifacts to Avoid:

1. Generic opening phrases:
   - "In this digital age"
   - "In today's world"
   - "It's worth noting"
   - "At its core"
   - "In the realm of"
   - "In the landscape of"

2. Overly formal transitions:
   - "Furthermore"
   - "Moreover"
   - "Additionally"
   - "In conclusion"
   - "To summarize"
   - "It should be noted"

3. Redundant phrases:
   - "It's important to note that"
   - "It's worth mentioning"
   - "It's crucial to understand"
   - "It's essential to recognize"

4. Generic conclusions:
   - "The future looks bright"
   - "Only time will tell"
   - "The possibilities are endless"
   - "The sky's the limit"

5. Overly enthusiastic language:
   - "amazing"
   - "incredible"
   - "revolutionary"
   - "game-changing"
   - "groundbreaking"

6. AI-typical sentence patterns:
   - Repetitive sentence structures
   - Unnatural word choices
   - Overly complex explanations
   - Generic advice and recommendations`;



        async function executeCSVWorkflow() {
            // Get API key from settings or localStorage
            let apiKey = workflowConfig.apiKey || localStorage.getItem('openaiApiKey');
            if (!apiKey) {
                alert('Please configure your OpenAI API key in Settings first');
                // Ensure DOM is ready before showing settings
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', showSettings);
                } else {
                    showSettings();
                }
                return;
            }
            const topic = document.getElementById('topic').value;
            const primaryKeyword = document.getElementById('primaryKeyword').value;
            const articleType = document.getElementById('articleType').value;
            const clientSelect = document.getElementById('clientSelect');
            const clientId = clientSelect.value;
            const clientName = clientId ? CLIENT_DATA[clientId]?.name || 'Unknown' : '';
            const context = document.getElementById('context').value;
            const toneBrand = clientId ? CLIENT_DATA[clientId]?.tone || 'No specific tone guidelines provided.' : 'No specific tone guidelines provided.';
            const aiArtifacts = CODIFIED_AI_ARTIFACTS;

            // Update supporting keywords from form
            updateSupportingKeywords();

            if (!clientId) {
                alert('Please select a client or choose Sandbox mode');
                return;
            }

            // Store configuration with enhanced keyword system
            const keywords = getAllKeywords();
            workflowConfig = { 
                apiKey, 
                topic, 
                keywords, 
                primaryKeyword, 
                supportingKeywords: keywords.supporting,
                articleType, 
                clientName, 
                clientId, 
                context, 
                toneBrand, 
                aiArtifacts 
            };
            
            // Reset global citations for new article
            resetGlobalCitations();
            
            // Update client memory with tone and AI artifacts preferences
            if (clientName) {
                if (toneBrand) {
                    updateClientMemory(clientName, 'tone_preference', toneBrand);
                }
                if (aiArtifacts) {
                    updateClientMemory(clientName, 'ai_artifacts', aiArtifacts);
                }
            }
            
            // Reset workflow state
            currentStep = 0;
            generatedContent = {};
            previousSummary = '';

            // Hide other sections and show step review
            document.getElementById('loading').classList.remove('show');
            document.getElementById('outputSection').style.display = 'none';
            document.getElementById('stepReviewSection').classList.add('show');

            // Fork the workflow based on article type
            if (articleType === 'list-based') {
                await executeListBasedWorkflow();
            } else {
                await executeGeneralWorkflow();
            }
        }

        async function executeListBasedWorkflow() {
            // Step 1: Generate outline
            currentStep = 1;
            updateProgressIndicator();
            
            document.getElementById('stepTitle').textContent = 'Step 1: Listicle Outline Generation';
            document.getElementById('stepNumber').textContent = '1/2';
            
            // Show loading
            document.getElementById('loading').classList.add('show');
            updateLoading('Step 1: Listicle Outline Generation...');
            
            try {
                const prompt = getListBasedPrompt();
                const content = await callOpenAI(workflowConfig.apiKey, prompt);
                generatedContent.outline = content;
                
                // Clean up and validate the content
                const cleanedContent = cleanGeneratedContent(content);
                
                // Show the outline for review
                document.getElementById('loading').classList.remove('show');
                document.getElementById('stepContentTextarea').value = cleanedContent;
                document.getElementById('stepReviewSection').classList.add('show');
                
            } catch (error) {
                document.getElementById('loading').classList.remove('show');
                alert(`Error generating outline: ${error.message}`);
            }
        }

        async function executeGeneralWorkflow() {
            // Start with step 1
            await executeStep(1);
        }

        async function executeStep(stepNumber) {
            // This function now only handles general articles
            currentStep = stepNumber;
            updateProgressIndicator();
            
            const stepNames = [
                '', // 0-indexed
                'Outline Generation',
                'Introduction Generation', 
                'First Section',
                'Second Section',
                'Third Section',
                'Fourth Section',
                'Fifth Section',
                'Sixth Section',
                'Title Generation',
                'Conclusion Generation'
            ];

            document.getElementById('stepTitle').textContent = `Step ${stepNumber}: ${stepNames[stepNumber]}`;
            document.getElementById('stepNumber').textContent = `${stepNumber}/10`;
            
            // Show loading for this step
            document.getElementById('loading').classList.add('show');
            updateLoading(`Step ${stepNumber}: ${stepNames[stepNumber]}...`);

            try {
                let content = '';
                let prompt = '';

                // Get user notes if any
                const notesTextarea = document.getElementById('stepNotesTextarea');
                const userNotes = notesTextarea ? notesTextarea.value.trim() : '';

                // General article workflow
                switch(stepNumber) {
                    case 1:
                        prompt = getOutlinePrompt(userNotes);
                        content = await callOpenAI(workflowConfig.apiKey, prompt);
                        break;
                    case 2:
                        prompt = getIntroductionPrompt(userNotes);
                        content = await callOpenAI(workflowConfig.apiKey, prompt);
                        break;
                    case 3:
                        prompt = getSectionPrompt(1, userNotes);
                        content = await callOpenAI(workflowConfig.apiKey, prompt);
                        break;
                    case 4:
                        prompt = getSectionPrompt(2, userNotes);
                        content = await callOpenAI(workflowConfig.apiKey, prompt);
                        break;
                    case 5:
                        prompt = getSectionPrompt(3, userNotes);
                        content = await callOpenAI(workflowConfig.apiKey, prompt);
                        break;
                    case 6:
                        prompt = getSectionPrompt(4, userNotes);
                        content = await callOpenAI(workflowConfig.apiKey, prompt);
                        break;
                    case 7:
                        prompt = getSectionPrompt(5, userNotes);
                        content = await callOpenAI(workflowConfig.apiKey, prompt);
                        break;
                    case 8:
                        prompt = getSectionPrompt(6, userNotes);
                        content = await callOpenAI(workflowConfig.apiKey, prompt);
                        break;
                    case 9:
                        prompt = getTitlePrompt(userNotes);
                        content = await callOpenAI(workflowConfig.apiKey, prompt);
                        break;
                    case 10:
                        prompt = getConclusionPrompt(userNotes);
                        content = await callOpenAI(workflowConfig.apiKey, prompt);
                        break;
                }

                // Store the generated content
                const stepKey = getStepKey(stepNumber);
                generatedContent[stepKey] = content;

                // Show content for review
                document.getElementById('loading').classList.remove('show');
                document.getElementById('stepContentTextarea').value = content;

                // Auto-continue for steps 2-9 (only show approval for outline and final)
                if (stepNumber >= 2 && stepNumber <= 9) {
                    // Update previous summary for next sections
                    if (stepNumber >= 3 && stepNumber <= 8) {
                        updatePreviousSummary();
                    }
                    
                    // Auto-continue to next step after a brief delay
                    setTimeout(() => {
                        if (stepNumber < 10) {
                            executeStep(stepNumber + 1);
                        } else {
                            finishWorkflow();
                        }
                    }, 1000); // 1 second delay to show the content briefly
                }

            } catch (error) {
                document.getElementById('loading').classList.remove('show');
                alert(`Error in step ${stepNumber}: ${error.message}`);
            }
        }

        async function executeListBasedStep2() {
            // Step 2: Generate full article based on approved outline
            currentStep = 2;
            updateProgressIndicator();
            
            document.getElementById('stepTitle').textContent = 'Step 2: Listicle Article Generation';
            document.getElementById('stepNumber').textContent = '2/2';
            
            // Show loading
            document.getElementById('loading').classList.add('show');
            updateLoading('Step 2: Listicle Article Generation...');
            
            try {
                // Extract section headings from the outline
                const sectionHeadings = extractSectionHeadings(generatedContent.outline);
                
                // Generate introduction
                updateLoading('Generating introduction...');
                const introPrompt = getListBasedIntroductionPrompt();
                const introduction = await callOpenAI(workflowConfig.apiKey, introPrompt);
                
                // Store all sections
                const sections = [
                    { title: 'Introduction', content: introduction }
                ];
                
                // Generate each company section with previous summary
                let previousSummary = '';
                for (let i = 0; i < sectionHeadings.length; i++) {
                    const heading = sectionHeadings[i];
                    updateLoading(`Generating section ${i + 1}/${sectionHeadings.length}: ${heading}...`);
                    
                    const sectionPrompt = getListBasedSectionPrompt(heading, i + 1, previousSummary);
                    const sectionContent = await callOpenAI(workflowConfig.apiKey, sectionPrompt);
                    
                    sections.push({
                        title: heading,
                        content: sectionContent
                    });
                    
                    // Update previous summary for next section
                    previousSummary = createSummaryFromSections(sections);
                }
                
                // Generate conclusion
                updateLoading('Generating conclusion...');
                const conclusionPrompt = getListBasedConclusionPrompt(previousSummary);
                const conclusion = await callOpenAI(workflowConfig.apiKey, conclusionPrompt);
                sections.push({ title: 'Conclusion', content: conclusion });
                
                // Combine all sections into full article
                let fullArticle = '';
                for (let section of sections) {
                    fullArticle += `## ${section.title}\n\n${section.content}\n\n`;
                }
                
                generatedContent.section1 = fullArticle; // Store full article in section1
                generatedContent.sections = sections; // Store individual sections for parsing
                
                // Clean up the full article
                const cleanedFullArticle = cleanGeneratedContent(fullArticle);
                
                // Show the full article for review
                document.getElementById('loading').classList.remove('show');
                document.getElementById('stepContentTextarea').value = cleanedFullArticle;
                document.getElementById('stepReviewSection').classList.add('show');
                
            } catch (error) {
                document.getElementById('loading').classList.remove('show');
                alert(`Error generating full article: ${error.message}`);
            }
        }

        function getStepKey(stepNumber) {
            const keys = ['', 'outline', 'introduction', 'section1', 'section2', 'section3', 'section4', 'section5', 'section6', 'title', 'conclusion'];
            return keys[stepNumber];
        }

        function getListBasedPrompt() {
            let prompt = `You are an expert content creator with a talent for crafting engaging, informative listicle blog post. Your task is to create a comprehensive, well-structured listicle outline on the given topic based on the following guidelines. You are writing in English (US) language only.

IMPORTANT: Only output the requested content (outline/article). Do NOT include any instructions, guidelines, or meta-text in your response. 

CRITICAL REQUIREMENT - USE REAL COMPANY NAMES:
- You MUST use real, well-known company names and products in your outline headings
- NEVER use generic placeholders like "Company A", "Software B", "Tool X", "Platform Y", etc.
- Research actual companies that offer solutions in this space and include their real names
- Examples of real companies: "Slack", "Microsoft Teams", "Zoom", "Salesforce", "HubSpot", "Shopify", "Stripe", "Mailchimp", "Canva", "Adobe", "Google", "Amazon", "Apple", etc.

WRITING INSTRUCTIONS: 
- Start with an "Introduction" section that explains what to look for in the software category and key benefits
- Ensure that the order of the h2 headings follows a logical progression, such as chronological order, order of importance, or categorical grouping. 
- Use parallel structure for each h2 headings, starting with the same part of speech or phrase structure to maintain consistency. 
- Incorporate relevant keywords and phrases naturally throughout the outline, including in the headings, and subheadings. 
- Organize the listicle into a numbered list of main points, ensuring that each point is concise, informative, and relevant to the overall theme.
- Include 8-10 main company recommendations in your outline, each with their own H2 heading.
- End with a "Conclusion" section that helps readers choose the right option. 

OUTPUT FORMAT: 
- Please make sure to always use Title case. 
- Use markdown ## for h2 headings and ### for h3 subheadings. 
- Do not return an explanation or a description or anything other than what you are asked for. 

OUTPUT LANGUAGE: English (US) 

The output should always be in the following markdown format - MARKDOWN OUTPUT FORMAT: 
\`\`\`markdown 
## Introduction
### What to Look For in [Topic] Software
### Key Benefits of Using Specialized Tools
## 1. [Company Name]  Best For [Specific Use Case]
### Key Features
### Benefits
## 2. [Company Name]  Best For [Specific Use Case]
### Key Features
### Benefits
## 3. [Company Name]  Best For [Specific Use Case]
### Key Features
### Benefits
## 4. [Company Name]  Best For [Specific Use Case]
### Key Features
### Benefits
## 5. [Company Name]  Best For [Specific Use Case]
### Key Features
### Benefits
## 6. [Company Name]  Best For [Specific Use Case]
### Key Features
### Benefits
## 7. [Company Name]  Best For [Specific Use Case]
### Key Features
### Benefits
## 8. [Company Name]  Best For [Specific Use Case]
### Key Features
### Benefits
## Conclusion
\`\`\`

Return a list of headings and nested subheadings to outline a listicle blog about "${workflowConfig.topic}" in English (US) language. TARGET KEYWORD: "${workflowConfig.primaryKeyword}" OUTPUT LANGUAGE: "English (US)"

${getKeywordPrompt()}

CRITICAL: Each H2 heading must use a REAL company name. Format: "## 1. [Real Company Name]  [What They're Best For]". Examples: "## 1. Slack  Best For Team Communication", "## 2. Microsoft Teams  Best For Enterprise Collaboration". NEVER use "Company A", "Software B", or any generic placeholders.

SPELLING REQUIREMENTS:
- SPELL ALL COMPANY NAMES CORRECTLY
- Double-check spelling before including any company names
- Common correct spellings: BrightEdge (not BrightEdae), SEMrush, Ahrefs, Moz, Screaming Frog, DeepCrawl, Majestic, Sistrix, SpyFu, Woorank, Botify, Conductor, SearchPilot, OnCrawl, Lumar, Sitebulb
- Each company should appear only ONCE in the outline
- Use unique, well-known companies for each recommendation`;

            // Add tone and brand guidelines if provided
            if (workflowConfig.toneBrand) {
                const truncatedToneBrand = truncateText(workflowConfig.toneBrand, 500);
                prompt += `\n\n## ADDITIONAL TONE GUIDELINES:\n${truncatedToneBrand}`;
            }

            // Add AI artifacts to avoid if provided
            if (workflowConfig.aiArtifacts) {
                const truncatedAIArtifacts = truncateText(workflowConfig.aiArtifacts, 500);
                prompt += `\n\n## WRITING INSTRUCTIONS - DO NOT INCLUDE THESE GUIDELINES IN YOUR OUTPUT:\n\nAI ARTIFACTS TO AVOID:\n${truncatedAIArtifacts}\n\nIMPORTANT: Follow these guidelines when writing, but do NOT include this instruction text in your article content.`;
            }


            return prompt;
        }

        function getListBasedIntroductionPrompt() {
            let prompt = `You are an expert blogger with years of experience writing high-quality, engaging articles on various topics. Your task is to create an introduction section for an article based on the following guidelines:

WRITING STYLE:
- Start with a brief introduction that attracts readers and provides context about the topic
- Keep the introduction short and engaging, with 2-3 brief paragraphs and a maximum of 150 words
- Do not say "here is the response" or "here is the introduction" or "sure here's the introduction", or any variation of that
- Use active voice for engaging writing
- Do not include too much information as this is just an introduction
- Use contractions wherever possible. For example: "it is" -> "it's", "I will" -> "I'll", etc.
- Do not use commas for pauses
- Do not include a header
- Use markdown for formatting

LANGUAGE: English (US)
WRITER PERSPECTIVE: Third person (he, she, it, they)
CONTENT TONE: SEO optimized (clear, knowledgeable and confident)

Write 2-3 brief paragraphs of the introduction for an article about "${workflowConfig.topic}" in 150 words in English (US) language. Do not say "here is the response" or "here is the introduction" or "sure here's the introduction", or any variation of that. Do not include too much information as this is just an introduction.`;

            if (workflowConfig.context) {
                const truncatedContext = truncateText(workflowConfig.context, 500);
                prompt += `\n\nADDITIONAL CONTEXT:\n${truncatedContext}`;
            }

            if (workflowConfig.toneBrand) {
                const truncatedToneBrand = truncateText(workflowConfig.toneBrand, 500);
                prompt += `\n\nTONE AND BRAND GUIDELINES:\n${truncatedToneBrand}`;
            }

            if (workflowConfig.aiArtifacts) {
                const truncatedAIArtifacts = truncateText(workflowConfig.aiArtifacts, 500);
                prompt += `\n\n## WRITING INSTRUCTIONS - DO NOT INCLUDE THESE GUIDELINES IN YOUR OUTPUT:\n\nAI ARTIFACTS TO AVOID:\n${truncatedAIArtifacts}\n\nIMPORTANT: Follow these guidelines when writing, but do NOT include this instruction text in your article content.`;
            }

            // Add client context if available
            if (workflowConfig.clientName) {
                const clientContext = getClientContext(workflowConfig.clientName);
                prompt += clientContext;
            }

            return prompt;
        }

        function getListBasedSectionPrompt(sectionHeading, sectionNumber, previousSummary = '') {
            let prompt = `You are an expert content creator with years of experience writing high-quality, engaging listicle articles on various topics. Your task is to create an informative and well-structured listicle article section based on the following guidelines and the pre-defined headings and subheadings.

WRITING STYLE:
- Use clear, concise language that is easy for readers to understand
- Be engaging and conversational, using a friendly tone to connect with the reader
- Use numeric values and qualify instances to provide specific information
- Give examples after plural nouns to provide clarity
- Use the same part of speech tag in the first word of each sentence in a listing
- Optimize the first sentence of each list item to match the heading
- Use contractions wherever possible. For example: "it is" -> "it's", "I will" -> "I'll", etc.
- Use commas only for lists and dates, not for pauses
- Use active voice to make the content more engaging
- Do not include a conclusion paragraph or sentence
- Use markdown for formatting

CONTENT GUIDELINES:
- Focus on providing valuable, actionable, or entertaining information
- Use short sentences instead of long ones, and keep the content as concise as possible while including necessary information
- Always provide information directly and precisely, citing authoritative sources when making statements
- Keep the content as short as possible while ensuring it is as long as necessary to convey the required information
- Trim the listicle article section to use fewer words while still including necessary entities and their connections in a descriptive and unique way

CONTEXTUAL FLOW AND STRUCTURE:
- Use the correct markdown format (e.g., paragraph, list, table) in the appropriate sections of the article based on the query network and macro context
- If there are numbers, data, or statistics in the response, create a markdown table for them
- Include headwords in the format of listings and use specific context terms inside each list item
- Use the pre-defined headings and subheadings to structure the article, ensuring that the content under each heading is relevant and follows a logical flow
- Use common anchor segments or concepts to connect the sections, improving the overall coherence of the article
- Throughout the article, use small, distinct contextual vectors that combine words from the H1 heading
- Distribute these vectors strategically to reinforce the main topic and maintain a consistent context
- Do not return an explanation or a description or anything other than what you are asked for
- Avoid including fluff and unnecessary details

LANGUAGE: English (US)
WRITER PERSPECTIVE: Third person (he, she, it, they)
CONTENT TONE: SEO optimized (clear, knowledgeable and confident)

We are writing a listicle blog post about "${workflowConfig.topic}" and need to create a section in English (US) language with the h2 heading "${sectionHeading}". You are tasked with optimizing the existing paragraphs under the pre-defined heading and subheadings to improve the quality of the content. If no paragraphs are present, you should write new content based on the given instructions. As this is an ongoing article, you should not include introduction and conclusion paragraphs in this section. Instead, focus on the main content of the section. Preserve the previous context to avoid repetition and ensure that content is coherent and flows naturally from the previous section to the current section.

CRITICAL: SPELL ALL COMPANY NAMES CORRECTLY. Double-check the spelling of any company names mentioned in the heading "${sectionHeading}". Common correct spellings include: BrightEdge (not BrightEdae), SEMrush, Ahrefs, Moz, Screaming Frog, DeepCrawl, Majestic, Sistrix, SpyFu, Woorank, Botify, Conductor, SearchPilot, OnCrawl, Lumar, Sitebulb, etc.`;

            if (previousSummary) {
                prompt += `\n\nPREVIOUS SUMMARY:\n"${previousSummary}"`;
            }

            if (workflowConfig.context) {
                const truncatedContext = truncateText(workflowConfig.context, 500);
                prompt += `\n\nADDITIONAL CONTEXT:\n${truncatedContext}`;
            }

            prompt += `\n\nStart the section with the H2 heading "${sectionHeading}" with 1-2 brief sentences if necessary. Then, optimize or write about the following subheadings with the corresponding content:
### Key Features
### Best For
### Pricing Snapshot
### Standout Integrations
### Why It Made The List`;

            if (workflowConfig.toneBrand) {
                const truncatedToneBrand = truncateText(workflowConfig.toneBrand, 500);
                prompt += `\n\nTONE AND BRAND GUIDELINES:\n${truncatedToneBrand}`;
            }

            if (workflowConfig.aiArtifacts) {
                const truncatedAIArtifacts = truncateText(workflowConfig.aiArtifacts, 500);
                prompt += `\n\n## WRITING INSTRUCTIONS - DO NOT INCLUDE THESE GUIDELINES IN YOUR OUTPUT:\n\nAI ARTIFACTS TO AVOID:\n${truncatedAIArtifacts}\n\nIMPORTANT: Follow these guidelines when writing, but do NOT include this instruction text in your article content.`;
            }

            // Add client context if available
            if (workflowConfig.clientName) {
                const clientContext = getClientContext(workflowConfig.clientName);
                prompt += clientContext;
            }

            return prompt;
        }

        function getListBasedConclusionPrompt(previousSummary = '') {
            let prompt = `You are an expert blogger with years of experience writing high-quality blog posts. You are writing based on the following information:

LANGUAGE: English (US)
WRITER PERSPECTIVE: Third person (he, she, it, they)
CONTENT TONE: SEO optimized (clear, knowledgeable and confident)
Use contractions wherever possible. For example: "it is" -> "it's", "I will" -> "I'll", etc.
Do not return an explanation or a description or anything other than what you are asked for.
Ensure that your content flows naturally and provides insightful information.
Make sure that you follow these rules:
- DO NOT use commas for pauses

Please write a conclusion section for a blog post about "${workflowConfig.topic}" in under 150 words. Do not include phrases such as "In conclusion, ...", "In summary, ..." or any variation of these. Since this section is just a conclusion, do not include too much information. Do no repeat what has been written in the article.`;

            if (workflowConfig.context) {
                const truncatedContext = truncateText(workflowConfig.context, 500);
                prompt += `\n\nADDITIONAL CONTEXT:\n${truncatedContext}`;
            }

            if (previousSummary) {
                prompt += `\n\nBelow is the summary of what have been written in the article.\n"${previousSummary}"`;
            }

            prompt += `\n\nLANGUAGE: English (US)
WRITER PERSPECTIVE: Third person (he, she, it, they)
CONTENT TONE: SEO optimized (clear, knowledgeable and confident)
Keep paragraphs short - no more than 3-4 lines of text per paragraph.
Start the section with the H2 heading "## Conclusion".
OUTPUT:`;

            if (workflowConfig.toneBrand) {
                const truncatedToneBrand = truncateText(workflowConfig.toneBrand, 500);
                prompt += `\n\nTONE AND BRAND GUIDELINES:\n${truncatedToneBrand}`;
            }

            if (workflowConfig.aiArtifacts) {
                const truncatedAIArtifacts = truncateText(workflowConfig.aiArtifacts, 500);
                prompt += `\n\n## WRITING INSTRUCTIONS - DO NOT INCLUDE THESE GUIDELINES IN YOUR OUTPUT:\n\nAI ARTIFACTS TO AVOID:\n${truncatedAIArtifacts}\n\nIMPORTANT: Follow these guidelines when writing, but do NOT include this instruction text in your article content.`;
            }

            // Add client context if available
            if (workflowConfig.clientName) {
                const clientContext = getClientContext(workflowConfig.clientName);
                prompt += clientContext;
            }

            return prompt;
        }

        function extractSectionHeadings(outline) {
            const headings = [];
            const seenHeadings = new Set();
            const lines = outline.split('\n');
            
            for (let line of lines) {
                if (line.startsWith('## ')) {
                    const heading = line.replace('## ', '').trim();
                    // Clean up the heading - remove numbering and normalize
                    const cleanHeading = heading.replace(/^\d+\.\s*/, '').trim();
                    
                    if (cleanHeading !== 'Introduction' && 
                        cleanHeading !== 'Conclusion' && 
                        !seenHeadings.has(cleanHeading)) {
                        headings.push(cleanHeading);
                        seenHeadings.add(cleanHeading);
                    }
                }
            }
            
            return headings;
        }

        function cleanGeneratedContent(content) {
            if (!content) return content;
            
            // Fix common company name misspellings
            const companyNameFixes = {
                'BrightEdae': 'BrightEdge',
                'proarammatic': 'programmatic',
                'BrightEdge takes the spotlight as a top proarammatic SEO to': 'BrightEdge takes the spotlight as a top programmatic SEO tool',
                'BrightEdge takes the spotlight as a top proarammatic SEO': 'BrightEdge takes the spotlight as a top programmatic SEO tool'
            };
            
            let cleanedContent = content;
            
            // Apply company name fixes
            for (const [wrong, correct] of Object.entries(companyNameFixes)) {
                cleanedContent = cleanedContent.replace(new RegExp(wrong, 'gi'), correct);
            }
            
            // Remove duplicate headers
            const lines = cleanedContent.split('\n');
            const seenHeaders = new Set();
            const cleanedLines = [];
            
            for (let line of lines) {
                if (line.startsWith('## ')) {
                    const header = line.trim();
                    if (!seenHeaders.has(header)) {
                        cleanedLines.push(line);
                        seenHeaders.add(header);
                    }
                } else {
                    cleanedLines.push(line);
                }
            }
            
            return cleanedLines.join('\n');
        }

        function createSummaryFromSections(sections) {
            let summary = '';
            for (let i = 0; i < sections.length; i++) {
                const section = sections[i];
                if (section.title && section.content) {
                    summary += `${section.title}: ${section.content.substring(0, 200)}... `;
                }
            }
            return summary.trim();
        }

        function getOutlinePrompt(userNotes = '') {
            let prompt = `You are an expert blogger with years of experience writing high-quality blog posts. Your task is to create a list of h2 and h3 headings to outline a blog post on the given topic based on the following guidelines. You are writing in English (US) language only.

IMPORTANT: Only output the requested content (outline). Do NOT include any instructions, guidelines, or meta-text in your response.

WRITING INSTRUCTIONS: - Include a "Conclusion" heading at the end. - Do not include an "Introduction" heading. - Do not include FAQs in the headings. - Avoid too many headings or subheadings. Aim for a short and balanced outline structure. OUTPUT FORMAT: - Make sure to always use Title case. - Use markdown ## for h2 headings and ### for h3 subheadings. - Do not return an explanation or a description or anything other than what you are asked for. OUTPUT LANGUAGE: English (US) The output should always be in the following markdown format - MARKDOWN OUTPUT FORMAT (without introduction item): \`\`\`markdown ## Heading 1 ## Heading 2 ### Subheading ### Subheading ## Heading 3 ### Subheading ## Heading 4 ## Heading 5 ## Conclusion \`\`\``;

            if (userNotes) {
                prompt += `\n\nUSER REGENERATION NOTES:\n${userNotes}\n\nPlease incorporate these specific instructions into the outline generation.`;
            }

            if (workflowConfig.context) {
                const truncatedContext = truncateText(workflowConfig.context, 500);
                prompt += `\n\nADDITIONAL CONTEXT:\n${truncatedContext}`;
            }

            if (workflowConfig.toneBrand) {
                const truncatedToneBrand = truncateText(workflowConfig.toneBrand, 500);
                prompt += `\n\nTONE AND BRAND GUIDELINES:\n${truncatedToneBrand}`;
            }

            if (workflowConfig.aiArtifacts) {
                const truncatedAIArtifacts = truncateText(workflowConfig.aiArtifacts, 500);
                prompt += `\n\n## WRITING INSTRUCTIONS - DO NOT INCLUDE THESE GUIDELINES IN YOUR OUTPUT:\n\nAI ARTIFACTS TO AVOID:\n${truncatedAIArtifacts}\n\nIMPORTANT: Follow these guidelines when writing, but do NOT include this instruction text in your article content.`;
            }

            // Add client context if available
            if (workflowConfig.clientName) {
                const clientContext = getClientContext(workflowConfig.clientName);
                prompt += clientContext;
            }

            prompt += `\n\nReturn a list of headings and nested subheadings to outline an article about "${workflowConfig.topic}" in English (US) language. TARGET KEYWORD: "${workflowConfig.primaryKeyword}" OUTPUT LANGUAGE: "English (US)"

${getKeywordPrompt()}`;

            return prompt;
        }

        function truncateText(text, maxLength) {
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '... [truncated]';
        }

        function getIntroductionPrompt(userNotes = '') {
            let prompt = `You are an expert content writer creating an engaging introduction for a blog post.

WRITING GUIDELINES:
- Write 2-3 paragraphs, maximum 150 words
- Use clear, direct language that hooks the reader
- Write in second person (you, your)
- Use active voice and contractions naturally
- Avoid fluff and overly flowery language
- Focus on the value readers will get
- Include specific facts or statistics if relevant

${workflowConfig.context ? `ADDITIONAL CONTEXT: ${workflowConfig.context}` : ''}`;

            if (userNotes) {
                prompt += `\n\nUSER REGENERATION NOTES:\n${userNotes}\n\nPlease incorporate these specific instructions into the introduction generation.`;
            }

            if (workflowConfig.toneBrand) {
                const truncatedToneBrand = truncateText(workflowConfig.toneBrand, 500);
                prompt += `\n\nTONE AND BRAND GUIDELINES:\n${truncatedToneBrand}`;
            }

            if (workflowConfig.aiArtifacts) {
                const truncatedAIArtifacts = truncateText(workflowConfig.aiArtifacts, 500);
                prompt += `\n\nWRITING QUALITY GUIDELINES (follow these but don't include in output):\n${truncatedAIArtifacts}`;
            }

            // Add client context if available
            if (workflowConfig.clientName) {
                const clientContext = getClientContext(workflowConfig.clientName);
                prompt += clientContext;
            }

            prompt += `\n\nTASK: Write an introduction for an article about "${workflowConfig.topic}".

OUTPUT: Write 2-3 engaging paragraphs that introduce the topic and explain what readers will learn. Do not include a heading.`;

            return prompt;
        }

        function getSectionPrompt(sectionNumber, userNotes = '') {
            // Generate dynamic section titles based on the actual topic
            const sectionTitles = [
                '',
                `What Is ${workflowConfig.topic.charAt(0).toUpperCase() + workflowConfig.topic.slice(1)} And Why It Matters`,
                `Key Features Of ${workflowConfig.topic.charAt(0).toUpperCase() + workflowConfig.topic.slice(1)}`,
                `Benefits Of Using ${workflowConfig.topic.charAt(0).toUpperCase() + workflowConfig.topic.slice(1)}`,
                `How ${workflowConfig.topic.charAt(0).toUpperCase() + workflowConfig.topic.slice(1)} Works`,
                `Best Practices For ${workflowConfig.topic.charAt(0).toUpperCase() + workflowConfig.topic.slice(1)}`,
                `Choosing The Right ${workflowConfig.topic.charAt(0).toUpperCase() + workflowConfig.topic.slice(1)} Solution`
            ];

            const sectionSubheadings = [
                '',
                '',
                '### Core Functionality\n### Advanced Features',
                '### Efficiency Improvements\n### Cost Savings',
                '### Implementation Process\n### Integration Options',
                '### Setup Guidelines\n### Maintenance Tips',
                '### Key Considerations\n### Comparison Factors'
            ];

            let prompt = `You are an expert content writer creating a high-quality blog post. Write clear, informative content that provides real value to readers.

WRITING GUIDELINES:
- Use clear, direct language that's easy to understand
- Write in second person (you, your)
- Use active voice and short sentences
- Include specific facts, data, and examples
- Avoid fluff, repetition, and overly flowery language
- Be informative and actionable
- Use contractions naturally (it's, you'll, etc.)
- Focus on providing practical value

CONTENT REQUIREMENTS:
- Write 300-500 words for this section
- Include specific information and examples
- Use markdown formatting appropriately
- Make content scannable with subheadings
- Avoid generic statements and clichs
- Provide actionable insights

${workflowConfig.context ? `ADDITIONAL CONTEXT: ${workflowConfig.context}` : ''}`;

            if (userNotes) {
                prompt += `\n\nUSER REGENERATION NOTES:\n${userNotes}\n\nPlease incorporate these specific instructions into the section generation.`;
            }

            if (workflowConfig.toneBrand) {
                const truncatedToneBrand = truncateText(workflowConfig.toneBrand, 500);
                prompt += `\n\nTONE AND BRAND GUIDELINES:\n${truncatedToneBrand}`;
            }

            if (workflowConfig.aiArtifacts) {
                const truncatedAIArtifacts = truncateText(workflowConfig.aiArtifacts, 500);
                prompt += `\n\nWRITING QUALITY GUIDELINES (follow these but don't include in output):\n${truncatedAIArtifacts}`;
            }

            // Add client context if available
            if (workflowConfig.clientName) {
                const clientContext = getClientContext(workflowConfig.clientName);
                prompt += clientContext;
            }

            prompt += `\n\nTASK: Write a section for a blog post about "${workflowConfig.topic}".

SECTION HEADING: "## ${sectionTitles[sectionNumber]}"${sectionSubheadings[sectionNumber] ? '\n\nSUBSECTIONS TO COVER:\n' + sectionSubheadings[sectionNumber] : ''}

PREVIOUS CONTEXT: "${previousSummary}"

KEYWORDS TO INCLUDE (if relevant): "${workflowConfig.primaryKeyword}"

${getKeywordPrompt()}

OUTPUT FORMAT: Start with the H2 heading, then write informative content with subheadings as needed. Do not include introduction or conclusion paragraphs.`;

            return prompt;
        }

        function getTitlePrompt(userNotes = '') {
            let prompt = `You are an expert blogger with years of experience writing high-quality blog posts. You are writing in English (US) language only. Write like a human using common words. Do not return an explanation or a description or anything other than what you are asked for.`;


            if (workflowConfig.toneBrand) {
                const truncatedToneBrand = truncateText(workflowConfig.toneBrand, 500);
                prompt += `\n\nTONE AND BRAND GUIDELINES:\n${truncatedToneBrand}`;
            }

            if (workflowConfig.aiArtifacts) {
                const truncatedAIArtifacts = truncateText(workflowConfig.aiArtifacts, 500);
                prompt += `\n\n## WRITING INSTRUCTIONS - DO NOT INCLUDE THESE GUIDELINES IN YOUR OUTPUT:\n\nAI ARTIFACTS TO AVOID:\n${truncatedAIArtifacts}\n\nIMPORTANT: Follow these guidelines when writing, but do NOT include this instruction text in your article content.`;
            }

            // Add client context if available
            if (workflowConfig.clientName) {
                const clientContext = getClientContext(workflowConfig.clientName);
                prompt += clientContext;
            }

            prompt += `\n\nWrite a perfectly SEO-friendly title for a blog post about "${workflowConfig.topic}" in under 100 characters. Below is the summary of what have been written in the article. "${previousSummary}"
TARGET KEYWORD: "${workflowConfig.primaryKeyword}"
LANGUAGE: English (US)

${getKeywordPrompt()}`;

            // Add user notes at the very end to ensure they take priority
            if (userNotes) {
                prompt += `\n\n FINAL REMINDER - CRITICAL USER INSTRUCTIONS:\n${userNotes}\n\nThese instructions are MANDATORY and must override any conflicting guidance above.`;
            }

            prompt += `\n\nTITLE:`;

            return prompt;
        }

        function getConclusionPrompt(userNotes = '') {
            let prompt = `You are an expert content writer creating a conclusion for a blog post.

WRITING GUIDELINES:
- Write 2-3 paragraphs, maximum 150 words
- Summarize key points without repeating everything
- End with actionable next steps or call-to-action
- Write in second person (you, your)
- Use active voice and contractions naturally
- Avoid phrases like "In conclusion" or "In summary"
- Focus on the value readers gained

${workflowConfig.context ? `ADDITIONAL CONTEXT: ${workflowConfig.context}` : ''}`;

            if (userNotes) {
                prompt += `\n\nUSER REGENERATION NOTES:\n${userNotes}\n\nPlease incorporate these specific instructions into the conclusion generation.`;
            }

            if (workflowConfig.toneBrand) {
                const truncatedToneBrand = truncateText(workflowConfig.toneBrand, 500);
                prompt += `\n\nTONE AND BRAND GUIDELINES:\n${truncatedToneBrand}`;
            }

            if (workflowConfig.aiArtifacts) {
                const truncatedAIArtifacts = truncateText(workflowConfig.aiArtifacts, 500);
                prompt += `\n\nWRITING QUALITY GUIDELINES (follow these but don't include in output):\n${truncatedAIArtifacts}`;
            }

            // Add client context if available
            if (workflowConfig.clientName) {
                const clientContext = getClientContext(workflowConfig.clientName);
                prompt += clientContext;
            }

            prompt += `\n\nTASK: Write a conclusion for a blog post about "${workflowConfig.topic}".

ARTICLE SUMMARY: "${previousSummary}"

OUTPUT: Start with "## Conclusion" then write 2-3 paragraphs that summarize key points and provide next steps.`;

            return prompt;
        }

        function updateProgressIndicator() {
            const dots = document.querySelectorAll('.progress-dot');
            const totalSteps = workflowConfig.articleType === 'list-based' ? 2 : 10;
            
            dots.forEach((dot, index) => {
                const stepNum = index + 1;
                dot.classList.remove('active', 'completed');
                
                // Only show dots for the current article type
                if (stepNum <= totalSteps) {
                    dot.style.display = 'block';
                    if (stepNum < currentStep) {
                        dot.classList.add('completed');
                    } else if (stepNum === currentStep) {
                        dot.classList.add('active');
                    }
                } else {
                    dot.style.display = 'none';
                }
            });
        }

        async function approveCurrentStep() {
            // Update the stored content with any edits made
            const stepKey = getStepKey(currentStep);
            generatedContent[stepKey] = document.getElementById('stepContentTextarea').value;

            // Update previous summary for next sections
            if (currentStep >= 3 && currentStep <= 8) {
                updatePreviousSummary();
            }

            // Handle different article types
            if (workflowConfig.articleType === 'list-based') {
                // For list-based articles, approve outline then generate full article
                if (currentStep === 1) {
                    // After outline approval, continue to step 2 (full article)
                    await executeListBasedStep2();
                } else if (currentStep === 2) {
                    // After full article generation, go to final review
                    finishWorkflow();
                }
            } else {
                // General article workflow
                if (currentStep === 1) {
                    // After outline approval, continue to next step
                    executeStep(currentStep + 1);
                } else if (currentStep < 10) {
                    // For all other steps, continue automatically without approval
                    executeStep(currentStep + 1);
                } else {
                    // Step 10 (conclusion) - finish workflow
                    finishWorkflow();
                }
            }
        }

        function regenerateCurrentStep() {
            executeStep(currentStep);
        }

        function toggleStepNotes() {
            const notesSection = document.getElementById('stepNotesSection');
            const addNotesBtn = document.getElementById('addNotesBtn');
            
            if (notesSection.style.display === 'none') {
                notesSection.style.display = 'block';
                addNotesBtn.textContent = ' Hide Notes';
                addNotesBtn.classList.add('active');
            } else {
                notesSection.style.display = 'none';
                addNotesBtn.textContent = ' Add Notes';
                addNotesBtn.classList.remove('active');
            }
        }

        function updatePreviousSummary() {
            // Build a proper summary of all completed content
            let summary = '';
            
            if (generatedContent.outline) {
                summary += `Outline: ${generatedContent.outline.substring(0, 200)}... `;
            }
            
            if (generatedContent.introduction) {
                summary += `Introduction: ${generatedContent.introduction.substring(0, 150)}... `;
            }
            
            if (generatedContent.section1) {
                summary += `Section 1: ${generatedContent.section1.substring(0, 150)}... `;
            }
            
            if (generatedContent.section2) {
                summary += `Section 2: ${generatedContent.section2.substring(0, 150)}... `;
            }
            
            if (generatedContent.section3) {
                summary += `Section 3: ${generatedContent.section3.substring(0, 150)}... `;
            }
            
            if (generatedContent.section4) {
                summary += `Section 4: ${generatedContent.section4.substring(0, 150)}... `;
            }
            
            if (generatedContent.section5) {
                summary += `Section 5: ${generatedContent.section5.substring(0, 150)}... `;
            }
            
            if (generatedContent.section6) {
                summary += `Section 6: ${generatedContent.section6.substring(0, 150)}... `;
            }
            
            previousSummary = summary;
        }

        function getFullArticleContext() {
            // Build a concise summary of the article for context (not full content)
            let context = '';
            
            if (generatedContent.title) {
                context += `Title: ${generatedContent.title}\n\n`;
            }
            
            if (generatedContent.introduction) {
                context += `Introduction: ${truncateText(generatedContent.introduction, 200)}\n\n`;
            }
            
            // For list-based articles, include section titles and brief summaries
            if (workflowConfig.articleType === 'list-based' && generatedContent.sections) {
                context += 'Article Structure:\n';
                for (let section of generatedContent.sections) {
                    if (section.title && section.content) {
                        context += `- ${section.title}: ${truncateText(section.content, 100)}\n`;
                    }
                }
                context += '\n';
            } else {
                // For general articles, include brief section summaries
                const sections = ['section1', 'section2', 'section3', 'section4', 'section5', 'section6'];
                for (let section of sections) {
                    if (generatedContent[section]) {
                        context += `${section}: ${truncateText(generatedContent[section], 100)}\n`;
                    }
                }
            }
            
            if (generatedContent.conclusion) {
                context += `Conclusion: ${truncateText(generatedContent.conclusion, 200)}\n\n`;
            }
            
            return context;
        }

        function parseListBasedContent(content) {
            // Parse the markdown content to extract sections
            const sections = [];
            const lines = content.split('\n');
            let currentSection = '';
            let currentTitle = '';
            let articleTitle = '';
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Check for H1 title (usually the main article title)
                if (line.startsWith('# ')) {
                    articleTitle = line.replace('# ', '').trim();
                    // Store the article title for later use
                    generatedContent.title = articleTitle;
                }
                // Check for H2 headings (company sections)
                else if (line.startsWith('## ')) {
                    // Save previous section if it exists
                    if (currentSection.trim()) {
                        sections.push({
                            title: currentTitle || 'Introduction',
                            content: currentSection.trim()
                        });
                    }
                    // Start new section
                    currentSection = line + '\n';
                    currentTitle = line.replace('## ', '').trim();
                }
                // Add content to current section
                else {
                    currentSection += line + '\n';
                }
            }
            
            // Add the last section
            if (currentSection.trim()) {
                sections.push({
                    title: currentTitle || 'Conclusion',
                    content: currentSection.trim()
                });
            }
            
            return sections;
        }

        function finishWorkflow() {
            
            // Hide step review and show final review
            document.getElementById('stepReviewSection').classList.remove('show');
            document.getElementById('finalReviewSection').classList.add('show');

            // Update section visibility based on article type
            updateSectionVisibility(workflowConfig.articleType);

            if (workflowConfig.articleType === 'list-based') {
                // For list-based articles, use stored sections if available, otherwise parse
                let sections;
                if (generatedContent.sections) {
                    sections = generatedContent.sections;
                } else {
                    const listBasedContent = generatedContent.section1 || generatedContent.outline || '';
                    sections = parseListBasedContent(listBasedContent);
                }
                
                // Clear all editors first
                document.getElementById('titleEditor').value = '';
                document.getElementById('introductionEditor').value = '';
                document.getElementById('conclusionEditor').value = '';
                
                // Clear static section editors
                for (let i = 1; i <= 6; i++) {
                    document.getElementById(`section${i}Editor`).value = '';
                }
                
                // Populate title if available
                if (generatedContent.title) {
                    document.getElementById('titleEditor').value = generatedContent.title;
                }
                
                // Populate sections based on content
                if (sections.length > 0) {
                    // Find and populate introduction
                    const introSection = sections.find(s => s.title.toLowerCase().includes('introduction'));
                    if (introSection) {
                        document.getElementById('introductionEditor').value = introSection.content;
                    }
                    
                    // Find and populate conclusion
                    const conclusionSection = sections.find(s => s.title.toLowerCase().includes('conclusion'));
                    if (conclusionSection) {
                        document.getElementById('conclusionEditor').value = conclusionSection.content;
                    }
                    
                    // Filter out introduction and conclusion sections for content sections
                    const contentSections = sections.filter(section => 
                        !section.title.toLowerCase().includes('introduction') && 
                        !section.title.toLowerCase().includes('conclusion')
                    );
                    
                    // Populate static section editors with content sections
                    contentSections.forEach((section, index) => {
                        if (index < 6) { // Limit to 6 sections
                            const sectionEditor = document.getElementById(`section${index + 1}Editor`);
                            if (sectionEditor) {
                                sectionEditor.value = `## ${section.title}\n\n${section.content}`;
                            }
                        }
                    });
                    
                    // Create dynamic sections for all content sections
                    createDynamicSections(sections);
                }
            } else {
                // General article workflow - populate all section editors
                const titleEditor = document.getElementById('titleEditor');
                const introductionEditor = document.getElementById('introductionEditor');
                const section1Editor = document.getElementById('section1Editor');
                const section2Editor = document.getElementById('section2Editor');
                const section3Editor = document.getElementById('section3Editor');
                const section4Editor = document.getElementById('section4Editor');
                const section5Editor = document.getElementById('section5Editor');
                const section6Editor = document.getElementById('section6Editor');
                const conclusionEditor = document.getElementById('conclusionEditor');


                if (titleEditor) {
                    titleEditor.value = generatedContent.title || '';
                }
                if (introductionEditor) {
                    introductionEditor.value = generatedContent.introduction || '';
                }
                if (section1Editor) {
                    section1Editor.value = generatedContent.section1 || '';
                }
                if (section2Editor) {
                    section2Editor.value = generatedContent.section2 || '';
                }
                if (section3Editor) {
                    section3Editor.value = generatedContent.section3 || '';
                }
                if (section4Editor) {
                    section4Editor.value = generatedContent.section4 || '';
                }
                if (section5Editor) {
                    section5Editor.value = generatedContent.section5 || '';
                }
                if (section6Editor) {
                    section6Editor.value = generatedContent.section6 || '';
                }
                if (conclusionEditor) {
                    conclusionEditor.value = generatedContent.conclusion || '';
                }
            }

            
            // Force show the final review section
            const finalReviewSection = document.getElementById('finalReviewSection');
            finalReviewSection.classList.add('show');
            finalReviewSection.style.display = 'block';
            
            // Also display the assembled article in the right pane
            displayAssembledArticle();
            
        }

        function displayAssembledArticle() {
            let finalContent = '';
            
            if (workflowConfig.articleType === 'list-based') {
                // For list-based articles, assemble from editors
                let title = document.getElementById('titleEditor').value;
                
                // If no title in editor, try to extract from content
                if (!title) {
                    // Try to extract title from the first section or content
                    const firstSection = document.querySelector('.dynamic-section textarea');
                    if (firstSection && firstSection.value) {
                        const titleMatch = firstSection.value.match(/^##\s+(\d+\.\s*.+?)(?:\s*-\s*(.+))?$/m);
                        if (titleMatch) {
                            // Extract the main topic from the first company name
                            const companyName = titleMatch[1].replace(/^\d+\.\s*/, '').trim();
                            title = `Best ${companyName} Tools: A Comprehensive Guide`;
                        }
                    }
                }
                
                // Final fallback
                if (!title) {
                    title = generatedContent.title || 'Best Tools Guide';
                }
                
                const introduction = document.getElementById('introductionEditor').value || '';
                const conclusion = document.getElementById('conclusionEditor').value || '';
                
                // Get dynamic sections
                const dynamicSections = getDynamicSectionContent();
                
                // Assemble the final article
                finalContent = `# ${title}\n\n`;
                if (introduction) finalContent += `## Introduction\n\n${introduction}\n\n`;
                
                // Add dynamic sections (content already includes headings)
                dynamicSections.forEach(section => {
                    finalContent += `${section.content}\n\n`;
                });
                
                if (conclusion) finalContent += `## Conclusion\n\n${conclusion}\n\n`;
                
                // Fallback to original content if no editors have content
                if (!finalContent.trim() || finalContent === `# ${title}\n\n`) {
                    finalContent = generatedContent.section1 || generatedContent.outline || '';
                }
            } else {
                // For general articles, assemble from all editors
                const title = document.getElementById('titleEditor').value || generatedContent.title || 'Untitled';
                const introduction = document.getElementById('introductionEditor').value || generatedContent.introduction || '';
                const section1 = document.getElementById('section1Editor').value || generatedContent.section1 || '';
                const section2 = document.getElementById('section2Editor').value || generatedContent.section2 || '';
                const section3 = document.getElementById('section3Editor').value || generatedContent.section3 || '';
                const section4 = document.getElementById('section4Editor').value || generatedContent.section4 || '';
                const section5 = document.getElementById('section5Editor').value || generatedContent.section5 || '';
                const section6 = document.getElementById('section6Editor').value || generatedContent.section6 || '';
                const conclusion = document.getElementById('conclusionEditor').value || generatedContent.conclusion || '';

                // Assemble final content
                finalContent = `# ${title}\n\n`;
                if (introduction) finalContent += `## Introduction\n\n${introduction}\n\n`;
                if (section1) finalContent += `${section1}\n\n`;
                if (section2) finalContent += `${section2}\n\n`;
                if (section3) finalContent += `${section3}\n\n`;
                if (section4) finalContent += `${section4}\n\n`;
                if (section5) finalContent += `${section5}\n\n`;
                if (section6) finalContent += `${section6}\n\n`;
                if (conclusion) finalContent += `## Conclusion\n\n${conclusion}\n\n`;
            }

            // Display in the right pane
            const outputArea = document.getElementById('outputText');
            if (outputArea) {
                outputArea.textContent = finalContent;
                // Note: Don't force show output section - let user approve first
            }
        }

        function updateLoading(text) {
            document.getElementById('loadingText').textContent = text;
        }

        // Review loading state management with whimsical leaf animation
        function setReviewLoading(buttonId, loadingText, reviewType) {
            const button = document.getElementById(buttonId);
            if (button) {
                button.classList.add('loading');
                button.setAttribute('data-loading-text', loadingText);
                button.disabled = true;
            }
            
            const loading = document.getElementById('reviewLoading');
            const reviewLoadingText = document.getElementById('reviewLoadingText');
            if (loading && reviewLoadingText) {
                loading.classList.add('show');
                reviewLoadingText.textContent = `${reviewType}...`;
            }
        }

        function setVerboseReviewLoading(buttonId, reviewType, steps) {
            const button = document.getElementById(buttonId);
            if (button) {
                button.classList.add('loading');
                button.disabled = true;
            }
            
            // Create enhanced loading modal
            const modal = document.createElement('div');
            modal.id = 'verboseReviewModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 12px;
                max-width: 500px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                text-align: center;
            `;

            modalContent.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div class="review-loading" style="margin-bottom: 15px;">
                        <div class="leaf-container">
                            <div class="floating-leaf"></div>
                        </div>
                    </div>
                    <h3 style="margin: 0 0 10px 0; color: #333;">${reviewType}</h3>
                    <p style="margin: 0; color: #666; font-size: 14px;">Processing your content...</p>
                </div>
                
                <div id="reviewSteps" style="text-align: left; margin-bottom: 20px;">
                    ${steps.map((step, index) => `
                        <div class="review-step" data-step="${index}" style="
                            padding: 8px 12px; 
                            margin: 5px 0; 
                            border-radius: 6px; 
                            background: #f8f9fa; 
                            border-left: 3px solid #e9ecef;
                            font-size: 14px;
                            color: #6c757d;
                        ">
                            <span class="step-icon" style="margin-right: 8px;"></span>
                            <span class="step-text">${step}</span>
                        </div>
                    `).join('')}
                </div>
                
                <div style="font-size: 12px; color: #999;">
                    This may take a few moments...
                </div>
            `;

            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        }

        function updateReviewStep(stepIndex, status = 'active') {
            // Check if the modal exists
            const modal = document.getElementById('verboseReviewModal');
            if (!modal) {
                console.warn(`Review modal not found when trying to update step ${stepIndex}`);
                return;
            }
            
            const step = document.querySelector(`[data-step="${stepIndex}"]`);
            if (!step) {
                console.warn(`Step ${stepIndex} not found in DOM`);
                return;
            }

            const icon = step.querySelector('.step-icon');
            const stepText = step.querySelector('.step-text');
            
            // Add null checks to prevent TypeError
            if (!icon) {
                console.warn(`Step icon not found for step ${stepIndex}`);
                return;
            }
            
            console.log(`Updating step ${stepIndex} to ${status}`);
            
            if (status === 'active') {
                step.style.background = '#e3f2fd';
                step.style.borderLeftColor = '#2196f3';
                step.style.color = '#1976d2';
                icon.textContent = '';
            } else if (status === 'completed') {
                step.style.background = '#e8f5e8';
                step.style.borderLeftColor = '#4caf50';
                step.style.color = '#2e7d32';
                icon.textContent = '';
            } else if (status === 'error') {
                step.style.background = '#ffebee';
                step.style.borderLeftColor = '#f44336';
                step.style.color = '#c62828';
                icon.textContent = '';
            }
        }

        function clearVerboseReviewLoading() {
            const modal = document.getElementById('verboseReviewModal');
            if (modal) {
                modal.remove();
            }
            
            // Also clear the old loading state
            const loading = document.getElementById('reviewLoading');
            if (loading) {
                loading.classList.remove('show');
            }
        }

        function clearReviewLoading(buttonId) {
            const button = document.getElementById(buttonId);
            if (button) {
                button.classList.remove('loading');
                button.removeAttribute('data-loading-text');
                button.disabled = false;
            }
            
            const loading = document.getElementById('reviewLoading');
            if (loading) {
                loading.classList.remove('show');
            }
        }

        // Citation progress management
        let citationProgressData = {
            totalClaims: 0,
            completedClaims: 0,
            foundCitations: 0,
            startTime: null,
            sections: [],
            currentSectionIndex: 0
        };

        function showCitationProgress(totalClaims, sections) {
            citationProgressData = {
                totalClaims: totalClaims,
                completedClaims: 0,
                foundCitations: 0,
                startTime: Date.now(),
                sections: sections,
                currentSectionIndex: 0
            };

            // Coffee modal is now handled at the research method selection level
            // No need to show it here anymore
        }

        function updateCitationProgress() {
            const totalEl = document.getElementById('totalClaims');
            const completedEl = document.getElementById('completedClaims');
            const foundEl = document.getElementById('foundCitations');
            const progressBar = document.getElementById('citationProgressBar');
            const currentSectionEl = document.getElementById('currentSection');
            const timeEstimateEl = document.getElementById('timeEstimate');

            if (totalEl) totalEl.textContent = citationProgressData.totalClaims;
            if (completedEl) completedEl.textContent = citationProgressData.completedClaims;
            if (foundEl) foundEl.textContent = citationProgressData.foundCitations;

            // Update progress bar
            const progressPercent = citationProgressData.totalClaims > 0 
                ? (citationProgressData.completedClaims / citationProgressData.totalClaims) * 100 
                : 0;
            if (progressBar) progressBar.style.width = `${progressPercent}%`;

            // Update current section
            if (currentSectionEl && citationProgressData.sections.length > 0) {
                const currentSection = citationProgressData.sections[citationProgressData.currentSectionIndex];
                if (currentSection) {
                    currentSectionEl.textContent = `Researching: ${currentSection}`;
                }
            }

            // Calculate time estimate
            if (timeEstimateEl && citationProgressData.startTime) {
                const elapsed = Date.now() - citationProgressData.startTime;
                const avgTimePerClaim = citationProgressData.completedClaims > 0 
                    ? elapsed / citationProgressData.completedClaims 
                    : 3000; // Default 3 seconds per claim
                
                const remainingClaims = citationProgressData.totalClaims - citationProgressData.completedClaims;
                const estimatedTimeRemaining = remainingClaims * avgTimePerClaim;
                
                if (estimatedTimeRemaining > 0) {
                    const minutes = Math.floor(estimatedTimeRemaining / 60000);
                    const seconds = Math.floor((estimatedTimeRemaining % 60000) / 1000);
                    
                    if (minutes > 0) {
                        timeEstimateEl.textContent = `Estimated time remaining: ${minutes}m ${seconds}s`;
                    } else {
                        timeEstimateEl.textContent = `Estimated time remaining: ${seconds}s`;
                    }
                } else {
                    timeEstimateEl.textContent = 'Almost done...';
                }
            }
        }

        function updateCitationProgressClaim(completed, found) {
            citationProgressData.completedClaims = completed;
            citationProgressData.foundCitations = found;
            updateCitationProgress();
        }

        function updateCitationProgressSection(sectionIndex) {
            citationProgressData.currentSectionIndex = sectionIndex;
            updateCitationProgress();
        }

        function hideCitationProgress() {
            const progress = document.getElementById('citationProgress');
            if (progress) {
                progress.classList.remove('show');
            }
        }

        // Coffee Modal Functions
        function showCoffeeModal() {
            const coffeeModal = document.getElementById('coffeeModal');
            if (coffeeModal) {
                coffeeModal.style.display = 'block';
                // Don't auto-hide - let user dismiss manually
            }
        }

        function hideCoffeeModal() {
            const coffeeModal = document.getElementById('coffeeModal');
            if (coffeeModal) {
                coffeeModal.style.display = 'none';
            }
        }

        function updateCoffeeProgress(sectionName) {
            const coffeeCurrentSection = document.getElementById('coffeeCurrentSection');
            if (coffeeCurrentSection) {
                coffeeCurrentSection.textContent = sectionName;
            }
        }

        function clearDisplayedArticle() {
            // Clear the right pane
            const outputArea = document.getElementById('outputText');
            if (outputArea) {
                outputArea.textContent = '';
            }
            
            // Hide the output section
            const outputSection = document.getElementById('outputSection');
            if (outputSection) {
                outputSection.classList.remove('show');
                outputSection.style.display = 'none';
                outputSection.style.visibility = 'hidden';
            }
            
            // Clear all section editors
            const editorIds = [
                'titleEditor', 'introductionEditor', 'conclusionEditor',
                'section1Editor', 'section2Editor', 'section3Editor', 
                'section4Editor', 'section5Editor', 'section6Editor'
            ];
            
            editorIds.forEach(editorId => {
                const editor = document.getElementById(editorId);
                if (editor) {
                    editor.value = '';
                }
            });
            
            // Clear dynamic sections if they exist
            const dynamicSections = document.getElementById('dynamicSections');
            if (dynamicSections) {
                dynamicSections.innerHTML = '';
            }
            
            // Clear generated content
            generatedContent = {};
            
            // Reset current article ID
            currentArticleId = null;
            
        }

        function forceShowOutputSection() {
            const outputSection = document.getElementById('outputSection');
            if (outputSection) {
                // Remove any conflicting classes
                outputSection.classList.remove('hidden');
                
                // Force show the section
                outputSection.style.display = 'block';
                outputSection.style.visibility = 'visible';
                outputSection.style.opacity = '1';
                outputSection.classList.add('show');
                
                // Ensure it's positioned correctly
                outputSection.style.position = 'relative';
                outputSection.style.zIndex = '1';
                
                
                // Scroll to the output section
                setTimeout(() => {
                    outputSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 200);
            } else {
                console.error('Output section not found!');
            }
        }

        // Add event listeners to section editors to update right pane in real-time
        function addSectionEditorListeners() {
            const editorIds = [
                'titleEditor', 'introductionEditor', 'conclusionEditor',
                'section1Editor', 'section2Editor', 'section3Editor', 
                'section4Editor', 'section5Editor', 'section6Editor'
            ];
            
            editorIds.forEach(editorId => {
                const editor = document.getElementById(editorId);
                if (editor) {
                    editor.addEventListener('input', () => {
                        // Debounce the update to avoid too many calls
                        clearTimeout(editor.updateTimeout);
                        editor.updateTimeout = setTimeout(() => {
                            displayAssembledArticle();
                        }, 500);
                    });
                }
            });
        }

        // Final review functions
        async function regenerateSection(sectionName) {
            const editor = document.getElementById(sectionName + 'Editor');
            const feedbackInput = document.getElementById(sectionName + 'Feedback');
            const originalValue = editor.value;
            
            // Get feedback
            const sectionFeedback = feedbackInput ? feedbackInput.value.trim() : '';
            const overallFeedback = ''; // Initialize overallFeedback to avoid undefined error
            
            // Get notes from step review section if available
            const notesTextarea = document.getElementById('stepNotesTextarea');
            const userNotes = notesTextarea ? notesTextarea.value.trim() : '';
            
            // Show loading state
            editor.value = 'Regenerating...';
            editor.disabled = true;

            try {
                // Use efficient approach for list-based articles
                if (workflowConfig.articleType === 'list-based') {
                    await regenerateListBasedSection(sectionName, originalValue, sectionFeedback, userNotes);
                } else {
                    // Special handling for title regeneration
                    if (sectionName === 'title') {
                        const prompt = getTitlePrompt(userNotes);
                        const newContent = await callOpenAI(workflowConfig.apiKey, prompt);
                        generatedContent.title = newContent;
                        editor.value = newContent;
                    } else {
                        // Use the existing approach for other sections
                        const articleContext = getFullArticleContext();
                        
                        // Build a focused prompt for section regeneration
                        let prompt = `You are an expert content writer. Revise the "${sectionName}" section based on user feedback.

ARTICLE CONTEXT:
${articleContext}

CURRENT SECTION CONTENT:
${originalValue}

TASK: Revise the "${sectionName}" section based on the feedback below while maintaining consistency with the rest of the article's tone, style, and content flow.

${userNotes ? `USER REGENERATION NOTES:\n${userNotes}\n\nPlease incorporate these specific instructions into the section revision.\n\n` : ''}WRITING GUIDELINES:
- Use clear, concise language that matches the article's tone
- Maintain consistency with the writing style used in other sections
- Ensure the revised section flows naturally with the surrounding content
- Use active voice and engaging language
- Include relevant examples and specific information
- Use markdown formatting appropriately
- Do not include conclusion phrases like "In conclusion" unless this is actually the conclusion section
- Keep the content focused and relevant to the topic: "${workflowConfig.topic}"

TONE AND BRAND GUIDELINES:`;

                    // Add tone and brand guidelines (reduced for token efficiency)
                    if (workflowConfig.toneBrand) {
                        const truncatedToneBrand = truncateText(workflowConfig.toneBrand, 200);
                        prompt += `\n${truncatedToneBrand}`;
                    } else {
                        prompt += `\nWrite in a professional, informative tone.`;
                    }

                    prompt += `\n\n## WRITING INSTRUCTIONS - DO NOT INCLUDE THESE GUIDELINES IN YOUR OUTPUT:\n\nAI ARTIFACTS TO AVOID:`;

                    // Add AI artifacts to avoid (reduced for token efficiency)
                    if (workflowConfig.aiArtifacts) {
                        const truncatedAIArtifacts = truncateText(workflowConfig.aiArtifacts, 200);
                        prompt += `\n${truncatedAIArtifacts}\n\nIMPORTANT: Follow these guidelines when writing, but do NOT include this instruction text in your article content.`;
                    } else {
                        prompt += `\nAvoid generic phrases and repetitive language.`;
                    }

                    // Add feedback prominently
                    if (sectionFeedback || overallFeedback) {
                        prompt += `\n\nREVISION FEEDBACK:\n`;
                        if (sectionFeedback) {
                            prompt += `Specific feedback for this section: ${sectionFeedback}\n`;
                        }
                        if (overallFeedback) {
                            prompt += `Overall article feedback: ${overallFeedback}\n`;
                        }
                        prompt += `\nIMPORTANT: Please revise this section based on the above feedback while maintaining consistency with the rest of the article.`;
                    }

                    // Add keyword integration requirements
                    prompt += `\n\n${getKeywordPrompt()}`;

                    // Add client context if available
                    if (workflowConfig.clientName) {
                        const clientContext = getClientContext(workflowConfig.clientName);
                        prompt += clientContext;
                    }

                    prompt += `\n\nOUTPUT: Provide only the revised content for the "${sectionName}" section. Do not include any explanations or meta-commentary.`;

                        const newContent = await callOpenAI(workflowConfig.apiKey, prompt);
                        generatedContent[sectionName] = newContent;
                        editor.value = newContent;
                    }
                }

                // Clear the feedback input
                if (feedbackInput) {
                    feedbackInput.value = '';
                }

            } catch (error) {
                editor.value = originalValue;
                alert(`Error regenerating ${sectionName}: ${error.message}`);
            } finally {
                editor.disabled = false;
            }
        }

        async function regenerateListBasedSection(sectionName, originalValue, sectionFeedback, userNotes = '') {
            const editor = document.getElementById(sectionName + 'Editor');
            const overallFeedback = ''; // Initialize overallFeedback to avoid undefined error
            
            // Update client memory with feedback
            if (workflowConfig.clientName && sectionFeedback) {
                updateClientMemory(workflowConfig.clientName, 'common_edit', {
                    section: sectionName,
                    feedback: sectionFeedback
                });
            }
            
            // Build a minimal, focused prompt for list-based sections
            let prompt = `Revise this ${sectionName} section for a listicle article about "${workflowConfig.topic}".

CRITICAL REQUIREMENT - USE REAL COMPANY NAMES:
- You MUST use real, well-known company names and products in your recommendations
- NEVER use generic placeholders like "Company A", "Software B", "Tool X", "Platform Y", etc.
- Research actual companies that offer solutions in this space and include their real names
- Include real features, pricing, and publicly available information
- Examples of real companies: "Slack", "Microsoft Teams", "Zoom", "Salesforce", "HubSpot", "Shopify", "Stripe", "Mailchimp", "Canva", "Adobe", "Google", "Amazon", "Apple", etc.

${userNotes ? ` CRITICAL USER OVERRIDE - HIGHEST PRIORITY:\n${userNotes}\n\nThese user instructions MUST override all other requirements above. Follow these instructions exactly.` : ''}

CURRENT CONTENT:
${originalValue}

WRITING STYLE:
- Use clear, concise language
- Include specific company details and features
- Use active voice and engaging language
- Include pricing and integration information
- Use markdown formatting
- Include subheadings: ### Key Features, ### Best For, ### Pricing Snapshot, ### Standout Integrations, ### Why It Made The List

TONE: Professional, informative, engaging

${getKeywordPrompt()}`;

            // Add client context if available
            if (workflowConfig.clientName) {
                const clientContext = getClientContext(workflowConfig.clientName);
                prompt += clientContext;
            }

            // Add minimal feedback
            if (sectionFeedback) {
                prompt += `\n\nFEEDBACK: ${sectionFeedback}`;
            }
            if (overallFeedback) {
                prompt += `\n\nOVERALL FEEDBACK: ${overallFeedback}`;
            }

            // Add minimal tone guidelines
            if (workflowConfig.toneBrand) {
                const truncatedToneBrand = truncateText(workflowConfig.toneBrand, 100);
                prompt += `\n\nTONE GUIDELINES: ${truncatedToneBrand}`;
            }

            // Add user notes if provided - FINAL OVERRIDE
            if (userNotes) {
                prompt += `\n\n FINAL USER OVERRIDE - MANDATORY INSTRUCTIONS:\n${userNotes}\n\nThese instructions MUST override ALL previous requirements. Follow these exactly.`;
            }

            prompt += `\n\nProvide only the revised ${sectionName} content. No explanations.`;

            const newContent = await callOpenAI(workflowConfig.apiKey, prompt);
            editor.value = newContent;
            editor.disabled = false;
        }

        async function regenerateEntireArticle() {
            if (!confirm('Are you sure you want to regenerate the entire article? This will overwrite all current content.')) {
                return;
            }

            // Reset and restart the workflow
            currentStep = 0;
            generatedContent = {};
            previousSummary = '';

            // Hide final review and show step review
            document.getElementById('finalReviewSection').classList.remove('show');
            document.getElementById('stepReviewSection').classList.add('show');

            // Start from step 1
            await executeStep(1);
        }

        function approveFinalArticle() {
            
            let finalContent = '';
            
            if (workflowConfig.articleType === 'list-based') {
                // For list-based articles, assemble content from all editors
                let title = document.getElementById('titleEditor').value;
                
                // If no title in editor, try to extract from content
                if (!title) {
                    // Try to extract title from the first section or content
                    const firstSection = document.querySelector('.dynamic-section textarea');
                    if (firstSection && firstSection.value) {
                        const titleMatch = firstSection.value.match(/^##\s+(\d+\.\s*.+?)(?:\s*-\s*(.+))?$/m);
                        if (titleMatch) {
                            // Extract the main topic from the first company name
                            const companyName = titleMatch[1].replace(/^\d+\.\s*/, '').trim();
                            title = `Best ${companyName} Tools: A Comprehensive Guide`;
                        }
                    }
                }
                
                // Final fallback
                if (!title) {
                    title = generatedContent.title || 'Best Tools Guide';
                }
                
                const introduction = document.getElementById('introductionEditor').value || '';
                const conclusion = document.getElementById('conclusionEditor').value || '';
                
                // Get dynamic sections
                const dynamicSections = getDynamicSectionContent();
                
                // Assemble the final article
                finalContent = `# ${title}\n\n`;
                if (introduction) finalContent += `## Introduction\n\n${introduction}\n\n`;
                
                // Add dynamic sections (content already includes headings)
                dynamicSections.forEach(section => {
                    finalContent += `${section.content}\n\n`;
                });
                
                if (conclusion) finalContent += `## Conclusion\n\n${conclusion}\n\n`;
                
                // Fallback to original content if no editors have content
                if (!finalContent.trim() || finalContent === `# ${title}\n\n`) {
                    finalContent = generatedContent.section1 || generatedContent.outline || '';
                }
            } else {
                // General article workflow - get content from all editors
                const title = document.getElementById('titleEditor').value || generatedContent.title || 'Untitled';
                const introduction = document.getElementById('introductionEditor').value || generatedContent.introduction || '';
                const section1 = document.getElementById('section1Editor').value || generatedContent.section1 || '';
                const section2 = document.getElementById('section2Editor').value || generatedContent.section2 || '';
                const section3 = document.getElementById('section3Editor').value || generatedContent.section3 || '';
                const section4 = document.getElementById('section4Editor').value || generatedContent.section4 || '';
                const section5 = document.getElementById('section5Editor').value || generatedContent.section5 || '';
                const section6 = document.getElementById('section6Editor').value || generatedContent.section6 || '';
                const conclusion = document.getElementById('conclusionEditor').value || generatedContent.conclusion || '';

                // Update generatedContent with the final values
                generatedContent.title = title;
                generatedContent.introduction = introduction;
                generatedContent.section1 = section1;
                generatedContent.section2 = section2;
                generatedContent.section3 = section3;
                generatedContent.section4 = section4;
                generatedContent.section5 = section5;
                generatedContent.section6 = section6;
                generatedContent.conclusion = conclusion;

                // Assemble final content
                finalContent = `# ${title}

${introduction}

${section1}

${section2}

${section3}

${section4}

${section5}

${section6}

${conclusion}`;
            }


            // Check if we have content
            if (!finalContent || finalContent.trim().length === 0) {
                alert('No content found! Please make sure the workflow completed successfully.');
                return;
            }

            // Save the article
            saveArticle(finalContent);

            // Hide final review and show final output
            document.getElementById('finalReviewSection').classList.remove('show');
            document.getElementById('outputText').textContent = finalContent;
            
            // Force show the output section
            const outputSection = document.getElementById('outputSection');
            outputSection.classList.add('show');
            outputSection.style.display = 'block';
            outputSection.style.visibility = 'visible';
            
            
            // Scroll to the final output
            setTimeout(() => {
                outputSection.scrollIntoView({ behavior: 'smooth' });
            }, 100);

            //  EASTER EGG: Explode confetti! 
            setTimeout(() => {
                explodeConfetti();
            }, 500);
        }



        async function reviewGrammar() {
            // Get all sections from editors
            const sections = collectAllSections();

            if (sections.length === 0) {
                alert('No content available for grammar review. Please generate an article first.');
                return;
            }

            try {
                // Set verbose loading state with detailed steps
                const steps = [
                    'Collecting article content from all sections',
                    'Analyzing grammar and punctuation',
                    'Checking sentence structure and flow',
                    'Reviewing word choice and clarity',
                    'Identifying style inconsistencies',
                    'Generating comprehensive feedback',
                    'Formatting results for review'
                ];
                
                setVerboseReviewLoading('grammarReviewBtn', 'Grammar & Style Review', steps);

                // Wait for modal to be fully rendered and visible
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Verify modal is created and visible
                const modal = document.getElementById('verboseReviewModal');
                if (!modal) {
                    console.error('Modal not created after setVerboseReviewLoading');
                    return;
                }
                
                console.log('Modal created, starting review steps...');

                // Step 1: Collecting content
                updateReviewStep(0, 'active');
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // OPTIMIZATION: Check cache first
                if (!hasContentChanged(sections)) {
                    const cachedResult = getCachedReview('grammar');
                    if (cachedResult) {
                        updateReviewStep(0, 'completed');
                        updateReviewStep(1, 'completed');
                        updateReviewStep(2, 'completed');
                        updateReviewStep(3, 'completed');
                        updateReviewStep(4, 'completed');
                        updateReviewStep(5, 'completed');
                        await new Promise(resolve => setTimeout(resolve, 500));
                        clearVerboseReviewLoading();
                        showReviewModal('Grammar & Style Review', cachedResult);
                        return;
                    }
                }
                
                updateReviewStep(0, 'completed');
                updateReviewStep(1, 'active');
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // OPTIMIZATION: Batch process all sections in a single API call
                const allContent = sections.map(section => 
                    `## ${section.title}\n${section.content}`
                ).join('\n\n');

                const prompt = `Review this article for grammar and style issues. Analyze each section and provide actionable feedback.

ARTICLE CONTENT:
${allContent}

Provide a comprehensive grammar and style review with:
1. Overall writing quality assessment
2. Section-by-section analysis
3. Specific issues and suggestions
4. Copy-paste feedback for each section

Format as:
# GRAMMAR & STYLE REVIEW

## OVERALL ASSESSMENT
[Brief overall quality score and main issues]

## SECTION-BY-SECTION ANALYSIS

${sections.map(s => `### ${s.title.toUpperCase()}
**Issues:** [Key grammar/style issues]
**Suggestions:** [Specific improvements]
**Copy-Paste Feedback:** [Concise feedback for regeneration]`).join('\n\n')}

## SUMMARY
[Key takeaways and priority fixes]

Be concise but thorough. Focus on actionable improvements.`;

                updateReviewStep(0, 'completed');
                updateReviewStep(1, 'active');
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                updateReviewStep(1, 'completed');
                updateReviewStep(2, 'active');
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                updateReviewStep(2, 'completed');
                updateReviewStep(3, 'active');
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                updateReviewStep(3, 'completed');
                updateReviewStep(4, 'active');
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                const review = await callOpenAI(workflowConfig.apiKey, prompt);
                
                updateReviewStep(4, 'completed');
                updateReviewStep(5, 'active');
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // OPTIMIZATION: Cache the result
                updateContentCache(sections, 'grammar', review);
                
                updateReviewStep(5, 'completed');
                updateReviewStep(6, 'active');
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                updateReviewStep(6, 'completed');
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                clearVerboseReviewLoading();
                showReviewModal('Grammar & Style Review', review);
                
            } catch (error) {
                alert(`Error performing grammar review: ${error.message}`);
                clearVerboseReviewLoading();
            } finally {
                // Re-enable button
                const button = document.getElementById('grammarReviewBtn');
                if (button) {
                    button.classList.remove('loading');
                    button.disabled = false;
                }
            }
        }

        async function reviewTone() {
            const toneBrand = workflowConfig.toneBrand || 'No specific tone guidelines provided.';
            
            // Get all sections from editors
            const sections = collectAllSections();

            if (sections.length === 0) {
                alert('No content available for tone review. Please generate an article first.');
                return;
            }

            try {
                // Set verbose loading state with detailed steps
                const steps = [
                    'Collecting article content and tone guidelines',
                    'Analyzing voice consistency across sections',
                    'Checking brand tone alignment',
                    'Identifying tone inconsistencies',
                    'Reviewing sentence structure and formality',
                    'Generating tone-specific feedback',
                    'Formatting results for review'
                ];
                
                setVerboseReviewLoading('toneReviewBtn', 'Tone & Voice Review', steps);

                // Wait for modal to be fully rendered and visible
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Verify modal is created and visible
                const modal = document.getElementById('verboseReviewModal');
                if (!modal) {
                    console.error('Modal not created after setVerboseReviewLoading');
                    return;
                }
                
                console.log('Modal created, starting review steps...');

                // Step 1: Collecting content
                updateReviewStep(0, 'active');
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // OPTIMIZATION: Check cache first
                if (!hasContentChanged(sections)) {
                    const cachedResult = getCachedReview('tone');
                    if (cachedResult) {
                        updateReviewStep(0, 'completed');
                        updateReviewStep(1, 'completed');
                        updateReviewStep(2, 'completed');
                        updateReviewStep(3, 'completed');
                        updateReviewStep(4, 'completed');
                        updateReviewStep(5, 'completed');
                        await new Promise(resolve => setTimeout(resolve, 500));
                        clearVerboseReviewLoading();
                        showReviewModal('Tone & Voice Review', cachedResult);
                        return;
                    }
                }
                
                updateReviewStep(0, 'completed');
                updateReviewStep(1, 'active');
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // STRATEGY: Try batch processing first, fall back to chunked processing
                let review;
                try {
                    // First attempt: Batch process all sections
                    review = await performBatchToneReview(sections, toneBrand);
                } catch (error) {
                    if (error.message.includes('token') || error.message.includes('context length')) {
                        console.log('Batch processing failed due to token limits, switching to chunked processing...');
                        setReviewLoading('toneReviewBtn', 'Processing chunks...', 'Tone & Voice Review');
                        review = await performChunkedToneReview(sections, toneBrand);
                    } else {
                        throw error;
                    }
                }
                
                // OPTIMIZATION: Cache the result
                updateContentCache(sections, 'tone', review);
                
                updateReviewStep(0, 'completed');
                updateReviewStep(1, 'completed');
                updateReviewStep(2, 'completed');
                updateReviewStep(3, 'completed');
                updateReviewStep(4, 'completed');
                updateReviewStep(5, 'active');
                await new Promise(resolve => setTimeout(resolve, 200));
                
                updateReviewStep(5, 'completed');
                updateReviewStep(6, 'active');
                await new Promise(resolve => setTimeout(resolve, 200));
                
                updateReviewStep(6, 'completed');
                await new Promise(resolve => setTimeout(resolve, 300));
                
                clearVerboseReviewLoading();
                showReviewModal('Tone & Voice Review', review);
                
            } catch (error) {
                alert(`Error performing tone review: ${error.message}`);
                clearVerboseReviewLoading();
            } finally {
                // Re-enable button
                const button = document.getElementById('toneReviewBtn');
                if (button) {
                    button.classList.remove('loading');
                    button.disabled = false;
                }
            }
        }

        // Batch processing for smaller content
        async function performBatchToneReview(sections, toneBrand) {
            const allContent = sections.map(section => 
                `## ${section.title}\n${section.content}`
            ).join('\n\n');

            const prompt = `You are an expert content reviewer specializing in brand voice and tone analysis. Review this article against the provided tone and brand guidelines.

TONE & BRAND GUIDELINES:
${toneBrand}

ARTICLE CONTENT:
${allContent}

Provide a comprehensive tone and voice review with:
1. Overall compliance assessment
2. Section-by-section analysis
3. Specific tone/voice issues and recommendations
4. Copy-paste feedback for each section

Format as:
# TONE & VOICE REVIEW

## OVERALL COMPLIANCE SCORE: [X/10]
[Brief overall assessment]

## SECTION-BY-SECTION ANALYSIS

${sections.map(s => `### ${s.title.toUpperCase()}
**Compliance Score:** [X/10]
**Issues:** [Specific tone/voice issues]
**Recommendations:** [Actionable improvements]
**Copy-Paste Feedback:** [Concise feedback for regeneration]`).join('\n\n')}

## SUMMARY
[Key takeaways and priority improvements]

Be concise but thorough. Focus on actionable improvements.`;

            return await callOpenAI(workflowConfig.apiKey, prompt);
        }

        // Chunked processing for larger content - process one section at a time
        async function performChunkedToneReview(sections, toneBrand) {
            const sectionReviews = [];
            let overallScore = 0;
            let totalSections = 0;

            // Process each section individually
            for (let i = 0; i < sections.length; i++) {
                const section = sections[i];
                updateLoading(`Analyzing tone and voice alignment... (${i + 1}/${sections.length})`);
                
                // Truncate section content if it's too long (keep first 2000 characters)
                const truncatedContent = section.content.length > 2000 
                    ? section.content.substring(0, 2000) + '... [Content truncated for analysis]'
                    : section.content;

                const prompt = `You are an expert content reviewer specializing in brand voice and tone analysis. Review this article section against the provided tone and brand guidelines.

TONE & BRAND GUIDELINES:
${toneBrand}

ARTICLE SECTION:
## ${section.title}
${truncatedContent}

Provide:
1. Compliance score (1-10)
2. Specific tone/voice issues
3. Actionable recommendations
4. Copy-paste feedback for regeneration

Format as:
## ${section.title.toUpperCase()}
**Compliance Score:** [X/10]
**Issues:** [Specific tone/voice issues]
**Recommendations:** [Actionable improvements]
**Copy-Paste Feedback:** [Concise feedback for regeneration]

Be concise but thorough. Focus on actionable improvements.`;

                try {
                    const sectionReview = await callOpenAI(workflowConfig.apiKey, prompt);
                    sectionReviews.push(sectionReview);
                    
                    // Extract score for overall calculation
                    const scoreMatch = sectionReview.match(/\*\*Compliance Score:\*\* \[(\d+)\/10\]/);
                    if (scoreMatch) {
                        const score = parseInt(scoreMatch[1]);
                        overallScore += score;
                        totalSections++;
                    }
                } catch (error) {
                    console.error(`Error processing section ${section.title}:`, error);
                    // Add a fallback review for this section
                    sectionReviews.push(`## ${section.title.toUpperCase()}
**Compliance Score:** [5/10]
**Issues:** [Error processing section - manual review recommended]
**Recommendations:** [Review this section manually for tone compliance]
**Copy-Paste Feedback:** [Manual review needed due to processing error]`);
                }
            }

            // Combine all reviews
            const averageScore = totalSections > 0 ? Math.round(overallScore / totalSections) : 0;
            
            let combinedReview = `# TONE & VOICE REVIEW

## OVERALL COMPLIANCE SCORE: ${averageScore}/10
${averageScore >= 8 ? 'Excellent tone alignment' : averageScore >= 6 ? 'Good tone alignment with some improvements needed' : 'Significant tone alignment issues detected'}

## SECTION-BY-SECTION ANALYSIS

${sectionReviews.join('\n\n')}

## SUMMARY
Review completed using individual section processing due to content length. Each section has been analyzed separately for tone and voice compliance.`;

            return combinedReview;
        }

        // Function to research citations using OpenAI
        // Function to validate URL accessibility with 200 OK response
        async function validateUrl(url) {
            if (!url || !url.startsWith('http')) {
                return { valid: false, status: 'Invalid URL format' };
            }

            try {
                // Use a CORS proxy or direct fetch with timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                
                const response = await fetch(url, {
                    method: 'HEAD', // Only check headers, don't download content
                    mode: 'no-cors', // Handle CORS issues
                    signal: controller.signal,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (compatible; CitationValidator/1.0)'
                    }
                });
                
                clearTimeout(timeoutId);
                
                // For no-cors mode, we can't read status, but if no error, assume it's accessible
                return { 
                    valid: true, 
                    status: 'Accessible',
                    statusCode: response.status || 'Unknown (no-cors)'
                };
                
            } catch (error) {
                // If CORS fails, try alternative validation
                try {
                    // Try a different approach using a CORS proxy
                    const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                    const proxyResponse = await fetch(proxyUrl, {
                        method: 'HEAD',
                        signal: AbortSignal.timeout(8000)
                    });
                    
                    return { 
                        valid: proxyResponse.ok, 
                        status: proxyResponse.ok ? 'Accessible via proxy' : 'Not accessible',
                        statusCode: proxyResponse.status
                    };
                } catch (proxyError) {
                    return { 
                        valid: false, 
                        status: `Error: ${error.message}`,
                        statusCode: 'Error'
                    };
                }
            }
        }

        // OpenAI Deep Research-powered citation system
        function generateChatGPTCitationPrompt(claims, sectionTitle) {
            // Get the full article content for context
            const sections = collectAllSections();
            const fullArticle = sections.map(section => 
                `## ${section.title}\n${section.content}`
            ).join('\n\n');

            return `I need help finding credible sources for specific claims in a business article. Please conduct thorough research and provide real, verifiable sources.

FULL ARTICLE DRAFT:
${fullArticle}

FOCUS SECTION: "${sectionTitle}"

SPECIFIC CLAIMS TO RESEARCH:
${claims.map((claim, index) => `${index + 1}. "${claim}"`).join('\n')}

RESEARCH REQUIREMENTS:
1. Find real, authoritative sources that support each claim
2. Prioritize academic journals, government reports, industry studies, and reputable news sources
3. Verify that sources actually support the specific claims
4. Include recent sources (preferably within last 3 years)
5. Ensure URLs are accessible and working
6. Provide proper citation formats (APA/MLA)
7. Consider the full article context when evaluating source relevance

SOURCE TYPES TO PRIORITIZE:
- Academic journals and research papers
- Government agencies and official reports
- Industry associations and trade publications
- Reputable news organizations (BBC, Reuters, AP, etc.)
- Established research institutions
- Professional organizations and standards bodies

OUTPUT FORMAT:
For each claim, provide:
- Source title
- Author(s)
- Publication/organization
- Publication date
- URL (verified working)
- Brief excerpt supporting the claim
- Credibility level (High/Medium/Low)
- Relevance (Direct/Indirect/Supporting)
- Proper academic citation

CRITICAL: Only include sources you can verify exist and actually support the claims. Do not fabricate or hallucinate sources.

Please conduct this research systematically, one claim at a time, and provide detailed results.`;
        }

        // Helper function to safely remove modals
        function removeModal(modal) {
            try {
                if (modal && modal.parentNode) {
                    document.body.removeChild(modal);
                    console.log('Modal removed successfully');
                    return true;
                } else if (modal) {
                    // Modal exists but has no parent, try to remove it anyway
                    modal.remove();
                    console.log('Modal removed (no parent)');
                    return true;
                }
            } catch (e) {
                console.log('Error removing modal:', e.message);
                // Try alternative removal method
                try {
                    if (modal) {
                        modal.remove();
                        console.log('Modal removed via alternative method');
                        return true;
                    }
                } catch (e2) {
                    console.log('Failed to remove modal:', e2.message);
                }
            }
            return false;
        }

        // Remove only the research method selection modal
        function removeResearchMethodModal() {
            console.log('Removing research method modal...');
            
            // Remove by ID first (most specific)
            const researchModal = document.getElementById('research-method-modal');
            if (researchModal) {
                console.log('Found research-method-modal by ID, removing...');
                try {
                    researchModal.style.display = 'none';
                    researchModal.style.visibility = 'hidden';
                    researchModal.style.opacity = '0';
                    if (researchModal.parentNode) {
                        document.body.removeChild(researchModal);
                    } else {
                        researchModal.remove();
                    }
                    console.log('Research method modal removed successfully');
                    return true;
                } catch (e) {
                    console.log('Force removal by ID failed:', e.message);
                }
            }
            
            // Fallback: Remove modals that contain the research method buttons
            const allModals = document.querySelectorAll('.modal');
            console.log(`Found ${allModals.length} modals with .modal class`);
            for (let i = 0; i < allModals.length; i++) {
                const modal = allModals[i];
                // Check if this modal has the research method buttons
                if (modal.querySelector('#chatgptBtn') || modal.querySelector('#automatedBtn')) {
                    console.log(`Removing research method modal ${i}:`, modal);
                    try {
                        modal.style.display = 'none';
                        modal.style.visibility = 'hidden';
                        modal.style.opacity = '0';
                        if (modal.parentNode) {
                            document.body.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                        console.log('Research method modal removed successfully');
                        return true;
                    } catch (e) {
                        console.log(`Force removal failed for modal ${i}:`, e.message);
                    }
                }
            }
            
            console.log('Research method modal removal complete');
            return false;
        }

        // Global function to manually remove research method modal (for debugging)
        window.removeResearchModal = function() {
            console.log('Manual research modal removal triggered');
            removeResearchMethodModal();
        };

        function showResearchMethodSelection(claims, sectionTitle) {
            return new Promise((resolve) => {
                // Remove any existing research method modals first
                const existingModals = document.querySelectorAll('.modal');
                existingModals.forEach(modal => {
                    if (modal.querySelector('#chatgptBtn') || modal.querySelector('#automatedBtn')) {
                        removeModal(modal);
                    }
                });
                
                // Also remove any modals with the research-method-modal ID
                const existingResearchModal = document.getElementById('research-method-modal');
                if (existingResearchModal) {
                    removeModal(existingResearchModal);
                }
                
                // Create modal
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.5);
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;

                const modalContent = document.createElement('div');
                modalContent.style.cssText = `
                    background: white;
                    padding: 30px;
                    border-radius: 8px;
                    max-width: 600px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                    text-align: center;
                `;

                modalContent.innerHTML = `
                    <h3>Choose Research Method for: "${sectionTitle}"</h3>
                    <p style="margin-bottom: 20px; color: #666;">
                        Found ${claims.length} claims that need citations. How would you like to research them?
                    </p>
                    
                    <div style="display: flex; gap: 15px; justify-content: center; margin-bottom: 20px;">
                        <button id="chatgptBtn" style="
                            background: #10a37f; 
                            color: white; 
                            border: none; 
                            padding: 15px 25px; 
                            border-radius: 6px; 
                            cursor: pointer;
                            font-size: 16px;
                            min-width: 200px;
                        ">
                            <strong>ChatGPT (Recommended)</strong><br>
                            <small>5-10 minutes  Manual but fast</small>
                        </button>
                        
                        <button id="automatedBtn" style="
                            background: #007bff; 
                            color: white; 
                            border: none; 
                            padding: 15px 25px; 
                            border-radius: 6px; 
                            cursor: pointer;
                            font-size: 16px;
                            min-width: 200px;
                        ">
                            <strong>Automated Research</strong><br>
                            <small>30+ minutes  Fully automated</small>
                        </button>
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 4px; margin-bottom: 20px; text-align: left;">
                        <strong>ChatGPT Method:</strong>
                        <ul style="margin: 5px 0 0 0; padding-left: 20px; font-size: 14px;">
                            <li>Get a pre-formatted prompt with all claims</li>
                            <li>Copy-paste into ChatGPT</li>
                            <li>Get results in 5-10 minutes</li>
                            <li>Manually add citations to your article</li>
                        </ul>
                    </div>
                    
                    <div style="background: #fff3cd; padding: 15px; border-radius: 4px; margin-bottom: 20px; text-align: left;">
                        <strong>Automated Method:</strong>
                        <ul style="margin: 5px 0 0 0; padding-left: 20px; font-size: 14px;">
                            <li>Uses OpenAI's Deep Research model</li>
                            <li>Fully automated - no manual work</li>
                            <li>Takes 30+ minutes per section</li>
                            <li>Citations automatically added to article</li>
                        </ul>
                    </div>
                    
                    <button id="cancelBtn" style="
                        background: #6c757d; 
                        color: white; 
                        border: none; 
                        padding: 8px 16px; 
                        border-radius: 4px; 
                        cursor: pointer;
                    ">
                        Cancel Research
                    </button>
                `;

                // Add event listeners with inline onclick (more reliable for this tech stack)
                modalContent.innerHTML = `
                    <h3>Choose Research Method for: "${sectionTitle}"</h3>
                    <p style="margin-bottom: 20px; color: #666;">
                        Found ${claims.length} claims that need citations. How would you like to research them?
                    </p>
                    
                    <div style="display: flex; gap: 15px; justify-content: center; margin-bottom: 20px;">
                        <button id="chatgptBtn" onclick="
                            console.log('ChatGPT button clicked');
                            this.closest('.modal').style.display = 'none';
                            this.closest('.modal').remove();
                            window.researchMethodResult = 'chatgpt';
                        " style="
                            background: #10a37f; 
                            color: white; 
                            border: none; 
                            padding: 15px 25px; 
                            border-radius: 6px; 
                            cursor: pointer;
                            font-size: 16px;
                            min-width: 200px;
                        ">
                            <strong>ChatGPT (Recommended)</strong><br>
                            <small>5-10 minutes  Manual but fast</small>
                        </button>
                        
                        <button id="automatedBtn" onclick="
                            console.log('Automated button clicked');
                            this.closest('.modal').style.display = 'none';
                            this.closest('.modal').remove();
                            window.researchMethodResult = 'automated';
                        " style="
                            background: #007bff; 
                            color: white; 
                            border: none; 
                            padding: 15px 25px; 
                            border-radius: 6px; 
                            cursor: pointer;
                            font-size: 16px;
                            min-width: 200px;
                        ">
                            <strong>Automated Research</strong><br>
                            <small>30+ minutes  Fully automated</small>
                        </button>
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 4px; margin-bottom: 20px; text-align: left;">
                        <strong>ChatGPT Method:</strong>
                        <ul style="margin: 5px 0 0 0; padding-left: 20px; font-size: 14px;">
                            <li>Get a pre-formatted prompt with all claims</li>
                            <li>Copy-paste into ChatGPT</li>
                            <li>Get results in 5-10 minutes</li>
                            <li>Manually add citations to your article</li>
                        </ul>
                    </div>
                    
                    <div style="background: #fff3cd; padding: 15px; border-radius: 4px; margin-bottom: 20px; text-align: left;">
                        <strong>Automated Method:</strong>
                        <ul style="margin: 5px 0 0 0; padding-left: 20px; font-size: 14px;">
                            <li>Uses OpenAI's Deep Research model</li>
                            <li>Fully automated - no manual work</li>
                            <li>Takes 30+ minutes per section</li>
                            <li>Citations automatically added to article</li>
                        </ul>
                    </div>
                    
                    <button id="cancelBtn" onclick="
                        console.log('Cancel button clicked');
                        this.closest('.modal').style.display = 'none';
                        this.closest('.modal').remove();
                        window.researchMethodResult = 'cancel';
                    " style="
                        background: #6c757d; 
                        color: white; 
                        border: none; 
                        padding: 8px 16px; 
                        border-radius: 4px; 
                        cursor: pointer;
                    ">
                        Cancel Research
                    </button>
                `;

                modal.className = 'modal';
                modal.id = 'research-method-modal';
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
                
                // Add click-outside-to-close functionality
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        modal.style.display = 'none';
                        modal.remove();
                        resolve('cancel');
                    }
                };
                
                // Poll for result from inline onclick handlers
                const pollForResult = () => {
                    if (window.researchMethodResult) {
                        const result = window.researchMethodResult;
                        window.researchMethodResult = null; // Reset
                        resolve(result);
                    } else {
                        setTimeout(pollForResult, 100);
                    }
                };
                
                // Start polling
                setTimeout(pollForResult, 100);
            });
        }

        function showChatGPTCitationModal(claims, sectionTitle) {
            const prompt = generateChatGPTCitationPrompt(claims, sectionTitle);
            
            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                padding: 20px;
                border-radius: 8px;
                max-width: 900px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            `;

            // Create ChatGPT URL with pre-filled prompt
            const encodedPrompt = encodeURIComponent(prompt);
            const chatgptUrl = `https://chatgpt.com/?q=${encodedPrompt}`;

            modalContent.innerHTML = `
                <h3>ChatGPT Citation Research</h3>
                <p style="margin-bottom: 20px; color: #666;">
                    Choose how you'd like to conduct citation research for this section. 
                    This is much faster than the automated process (5-10 minutes vs 30+ minutes).
                </p>
                
                <div style="display: flex; gap: 15px; justify-content: center; margin-bottom: 20px;">
                    <a href="${chatgptUrl}" target="_blank" onclick="this.closest('.modal').remove();" style="
                        background: #10a37f; 
                        color: white; 
                        text-decoration: none;
                        padding: 15px 25px; 
                        border-radius: 6px; 
                        font-size: 16px;
                        font-weight: bold;
                        min-width: 200px;
                        text-align: center;
                        display: inline-block;
                    ">
                         Open in ChatGPT
                        <br><small style="font-weight: normal;">One-click research</small>
                    </a>
                    
                    <button onclick="navigator.clipboard.writeText('${prompt.replace(/'/g, "\\'")}'); this.textContent='Copied!'; setTimeout(() => this.textContent='Copy Prompt', 2000); this.closest('.modal').remove();" 
                            style="
                                background: #007bff; 
                                color: white; 
                                border: none; 
                                padding: 15px 25px; 
                                border-radius: 6px; 
                                cursor: pointer;
                                font-size: 16px;
                                font-weight: bold;
                                min-width: 200px;
                            ">
                         Copy Prompt
                        <br><small style="font-weight: normal;">Manual paste</small>
                    </button>
                </div>

                <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px; border-left: 4px solid #10a37f;">
                    <strong> One-Click Method (Recommended):</strong>
                    <ul style="margin: 5px 0 0 0; padding-left: 20px; font-size: 14px;">
                        <li>Click "Open in ChatGPT" above</li>
                        <li>ChatGPT opens with the prompt pre-filled</li>
                        <li>Start research immediately</li>
                        <li>Results in 5-10 minutes</li>
                    </ul>
                </div>

                <div style="margin-bottom: 15px; padding: 10px; background: #e7f3ff; border-radius: 4px; border-left: 4px solid #007bff;">
                    <strong> Manual Method:</strong>
                    <ul style="margin: 5px 0 0 0; padding-left: 20px; font-size: 14px;">
                        <li>Click "Copy Prompt" above</li>
                        <li>Go to <a href="https://chatgpt.com" target="_blank">ChatGPT</a> manually</li>
                        <li>Paste the prompt in a new conversation</li>
                        <li>Start research</li>
                    </ul>
                </div>

                <details style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                    <summary style="cursor: pointer; font-weight: bold; color: #495057; margin-bottom: 10px;">
                         View Full Prompt
                    </summary>
                    <textarea readonly style="
                        width: 100%; 
                        height: 200px; 
                        padding: 10px; 
                        border: 1px solid #ced4da; 
                        border-radius: 4px; 
                        font-family: monospace; 
                        font-size: 12px; 
                        background: white;
                        resize: vertical;
                    ">${prompt}</textarea>
                    <div style="margin-top: 10px; font-size: 12px; color: #6c757d;">
                         Tip: You can copy this entire prompt and paste it directly into ChatGPT
                    </div>
                </details>

                <div style="text-align: center;">
                    <button onclick="this.closest('.modal').remove()" 
                            style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
                        Close
                    </button>
                </div>
            `;

            modal.className = 'modal';
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        }

        async function searchForCitations(claims, sectionTitle) {
            const citations = [];
            
            try {
                updateLoading(`Conducting deep research for: "${sectionTitle}"...`);
                
                // O3 Deep Research prompt for comprehensive source finding
                const researchPrompt = `You are a professional research assistant with access to web search and deep research capabilities. Your task is to find credible, verifiable sources for specific claims.

RESEARCH TASK: Find real, authoritative sources for these claims in the context of "${sectionTitle}":

${claims.map((claim, index) => `${index + 1}. "${claim}"`).join('\n')}

RESEARCH INSTRUCTIONS:
1. Use your deep research capabilities to find real, current sources that support each claim
2. Prioritize academic journals, government reports, industry studies, and reputable news sources
3. Verify that sources actually support the specific claims
4. Include recent sources (preferably within last 3 years)
5. Ensure URLs are accessible and working
6. Provide proper citation formats (APA/MLA)

SOURCE TYPES TO PRIORITIZE:
- Academic journals and research papers
- Government agencies and official reports
- Industry associations and trade publications
- Reputable news organizations (BBC, Reuters, AP, etc.)
- Established research institutions
- Professional organizations and standards bodies

OUTPUT FORMAT (JSON):
{
  "sources": [
    {
      "claim": "exact claim this source supports",
      "title": "Source Title",
      "author": "Author Name(s)",
      "publication": "Journal/Organization/Website",
      "date": "Publication Date",
      "url": "https://verified-working-url.com",
      "snippet": "Brief excerpt supporting the claim",
      "credibility": "High/Medium/Low",
      "relevance": "Direct/Indirect/Supporting",
      "citation_format": "Proper academic citation"
    }
  ],
  "research_summary": "Brief summary of findings",
  "verification_notes": "Any important verification details"
}

CRITICAL: Only include sources you can verify exist and actually support the claims. Do not fabricate or hallucinate sources.`;

                const researchResponse = await callOpenAI(workflowConfig.apiKey, researchPrompt, 'o3-deep-research');
                
                try {
                    const researchData = JSON.parse(researchResponse);
                    
                    if (researchData.sources && researchData.sources.length > 0) {
                        // Process each verified source
                        for (const source of researchData.sources) {
                            if (source.url && source.url.startsWith('http')) {
                                updateLoading(`Validating source: ${source.title.substring(0, 30)}...`);
                                
                                // Validate the URL
                                const validation = await validateUrl(source.url);
                                
                                if (validation.valid) {
                                    const citation = {
                                        claim: source.claim || claims[0], // Fallback to first claim if not specified
                                        source: source.title,
                                        author: source.author || 'Unknown',
                                        publication: source.publication || 'Unknown',
                                        date: source.date || 'Unknown',
                                        url: source.url,
                                        snippet: source.snippet || '',
                                        relevance: source.relevance || 'Medium',
                                        credibility: source.credibility || 'Medium',
                                        citationFormat: source.citation_format || '',
                                        validationStatus: validation.status,
                                        statusCode: validation.statusCode,
                                        verified: true
                                    };
                                    
                                    citations.push(citation);
                                    console.log(` Verified citation: ${source.title} (${validation.statusCode})`);
                                } else {
                                    console.log(` Invalid URL: ${source.url} - ${validation.status}`);
                                }
                            }
                        }
                    }
                    
                    // If no sources found, create research guidance
                    if (citations.length === 0) {
                        console.log(' No verified sources found, providing research guidance');
                        
                        for (const claim of claims) {
                            const guidanceCitation = {
                                claim: claim,
                                source: '[RESEARCH GUIDANCE]',
                                author: 'Research Required',
                                publication: 'Manual Research Needed',
                                date: 'Current',
                                url: 'https://scholar.google.com',
                                snippet: `Research needed for: "${claim}"`,
                                relevance: 'Unknown',
                                credibility: 'Unknown',
                                citationFormat: 'To be determined after research',
                                validationStatus: 'Requires manual research',
                                statusCode: 'Research Guidance',
                                requiresResearch: true
                            };
                            
                            citations.push(guidanceCitation);
                        }
                    }
                    
                } catch (parseError) {
                    console.error('Error parsing research response:', parseError);
                    console.log('Raw response:', researchResponse);
                    
                    // Fallback: provide research guidance
                    for (const claim of claims) {
                        const guidanceCitation = {
                            claim: claim,
                            source: '[RESEARCH GUIDANCE]',
                            author: 'Research Required',
                            publication: 'Manual Research Needed',
                            date: 'Current',
                            url: 'https://scholar.google.com',
                            snippet: `Research needed for: "${claim}"`,
                            relevance: 'Unknown',
                            credibility: 'Unknown',
                            citationFormat: 'To be determined after research',
                            validationStatus: 'Requires manual research',
                            statusCode: 'Research Guidance',
                            requiresResearch: true
                        };
                        
                        citations.push(guidanceCitation);
                    }
                }
                
            } catch (error) {
                console.error('Error in deep research:', error);
                
                // Fallback: provide research guidance
                for (const claim of claims) {
                    const guidanceCitation = {
                        claim: claim,
                        source: '[RESEARCH GUIDANCE]',
                        author: 'Research Required',
                        publication: 'Manual Research Needed',
                        date: 'Current',
                        url: 'https://scholar.google.com',
                        snippet: `Research needed for: "${claim}"`,
                        relevance: 'Unknown',
                        credibility: 'Unknown',
                        citationFormat: 'To be determined after research',
                        validationStatus: 'Requires manual research',
                        statusCode: 'Research Guidance',
                        requiresResearch: true
                    };
                    
                    citations.push(guidanceCitation);
                }
            }
            
            console.log(` Deep research complete: ${citations.length} sources found`);
            return citations;
        }


        async function reviewCitations() {
            // Get all sections from editors
            const sections = collectAllSections();

            if (sections.length === 0) {
                alert('No content available for citation review. Please generate an article first.');
                return;
            }

            try {
                // Define steps for verbose loading
                const steps = [
                    'Analyzing article content for citation needs',
                    'Identifying statistical and factual claims',
                    'Scanning for performance and comparison claims',
                    'Checking technical specifications and market data',
                    'Reviewing research findings and regulatory claims',
                    'Compiling comprehensive citation requirements',
                    'Preparing citation analysis results'
                ];
                
                setVerboseReviewLoading('citationsReviewBtn', 'Fact & Citation Review', steps);

                // Small delay to ensure modal is fully rendered
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Step 1: Collecting content
                updateReviewStep(0, 'active');
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // First, identify all claims that need verification
                const allClaims = [];
                const sectionClaims = [];
                
                updateReviewStep(0, 'completed');
                updateReviewStep(1, 'active');
                await new Promise(resolve => setTimeout(resolve, 200));
                
                updateReviewStep(1, 'completed');
                updateReviewStep(2, 'active');
                await new Promise(resolve => setTimeout(resolve, 200));
                
                for (const section of sections) {
                    const prompt = `Review this section for claims that NEED citations in online content publishing. Be thorough and flag any claim that readers would reasonably expect to be backed up with sources.

SECTION: ${section.title}
CONTENT: ${section.content}

Flag claims that meet these criteria:
1. STATISTICS & DATA: Any percentage, number, or quantitative claim ("X% of users", "increased by 50%", "reduces costs by $X", "most popular", "leading", "top-rated")
2. FACTS & SPECIFIC INFORMATION: Company details, dates, user counts, pricing, features, capabilities, market position
3. PERFORMANCE CLAIMS: Speed improvements, efficiency gains, time savings, productivity increases, conversion rates
4. COMPARISONS & RANKINGS: "better than", "faster than", "more popular than", "industry leader", "best", "worst"
5. TECHNICAL SPECIFICATIONS: System requirements, capabilities, limitations, supported formats, integrations
6. MARKET DATA: Industry trends, market size, growth rates, adoption rates, user behavior patterns
7. RESEARCH FINDINGS: Study results, survey data, research conclusions, expert opinions
8. REGULATORY/COMPLIANCE: Standards, certifications, compliance requirements, legal requirements
9. HISTORICAL FACTS: Company history, product evolution, market changes, timeline events
10. COMPETITIVE POSITIONING: Market share, competitive advantages, unique features, market position

DO NOT flag:
- General advice or recommendations without specific claims
- Common knowledge facts (like "the sky is blue")
- Obvious statements that don't need verification
- Subjective opinions clearly marked as such
- Generic marketing language without specific claims

Format your response as a JSON object with this structure:
{
  "statistics": ["statistical claims that need verification"],
  "facts": ["factual claims that need verification"],
  "performance": ["performance claims that need verification"],
  "comparisons": ["comparison claims that need verification"],
  "technical": ["technical claims that need verification"],
  "market": ["market data claims that need verification"],
  "research": ["research findings that need verification"],
  "regulatory": ["regulatory/compliance claims that need verification"],
  "historical": ["historical facts that need verification"],
  "competitive": ["competitive positioning claims that need verification"],
  "summary": "Brief summary of what needs citations"
}

Be thorough - flag any claim that would benefit from a source link, even if it seems obvious.`;

                    updateReviewStep(2, 'completed');
                    updateReviewStep(3, 'active');
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    const sectionReview = await callOpenAI(workflowConfig.apiKey, prompt);
                    
                    try {
                        const parsedReview = JSON.parse(sectionReview);
                        
                        const sectionClaimData = {
                            sectionTitle: section.title,
                            statistics: parsedReview.statistics || [],
                            facts: parsedReview.facts || [],
                            performance: parsedReview.performance || [],
                            comparisons: parsedReview.comparisons || [],
                            technical: parsedReview.technical || [],
                            market: parsedReview.market || [],
                            research: parsedReview.research || [],
                            regulatory: parsedReview.regulatory || [],
                            historical: parsedReview.historical || [],
                            competitive: parsedReview.competitive || [],
                            summary: parsedReview.summary || ''
                        };
                        
                        sectionClaims.push(sectionClaimData);
                        
                        // Add all claims to the master list
                        const claimTypes = [
                            'statistics', 'facts', 'performance', 'comparisons', 'technical',
                            'market', 'research', 'regulatory', 'historical', 'competitive'
                        ];
                        
                        claimTypes.forEach(type => {
                            if (parsedReview[type] && Array.isArray(parsedReview[type])) {
                                allClaims.push(...parsedReview[type].map(claim => ({
                                    claim: claim,
                                    section: section.title,
                                    type: type
                                })));
                            }
                        });
                        
                        updateReviewStep(3, 'completed');
                        updateReviewStep(4, 'active');
                        await new Promise(resolve => setTimeout(resolve, 200));
                        
                    } catch (parseError) {
                    }
                }
                
                updateReviewStep(4, 'completed');
                updateReviewStep(5, 'active');
                await new Promise(resolve => setTimeout(resolve, 200));
                
                updateReviewStep(5, 'completed');
                updateReviewStep(6, 'active');
                await new Promise(resolve => setTimeout(resolve, 200));
                
                updateReviewStep(6, 'completed');
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Show claims selection modal
                showClaimsSelectionModal(allClaims, sectionClaims);
                
            } catch (error) {
                alert(`Error performing citation review: ${error.message}`);
            } finally {
                clearVerboseReviewLoading();
            }
        }

        async function reviewAIArtifacts() {
            // Get all sections from editors
            const sections = collectAllSections();

            if (sections.length === 0) {
                alert('No content available for AI artifacts review. Please generate an article first.');
                return;
            }

            try {
                // Set verbose loading state with detailed steps
                const steps = [
                    'Collecting article content for analysis',
                    'Scanning for AI-generated language patterns',
                    'Identifying overly formal or robotic phrases',
                    'Detecting repetitive AI structures',
                    'Checking for generic transitions and connectors',
                    'Analyzing sentence complexity and variety',
                    'Generating humanization recommendations'
                ];
                
                setVerboseReviewLoading('aiArtifactsReviewBtn', 'AI Artifacts Review', steps);

                // Wait for modal to be fully rendered and visible
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Verify modal is created and visible
                const modal = document.getElementById('verboseReviewModal');
                if (!modal) {
                    console.error('Modal not created after setVerboseReviewLoading');
                    return;
                }
                
                console.log('Modal created, starting review steps...');

                // Step 1: Collecting content
                updateReviewStep(0, 'active');
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // OPTIMIZATION: Check cache first
                if (!hasContentChanged(sections)) {
                    const cachedResult = getCachedReview('aiArtifacts');
                    if (cachedResult) {
                        updateReviewStep(0, 'completed');
                        updateReviewStep(1, 'completed');
                        updateReviewStep(2, 'completed');
                        updateReviewStep(3, 'completed');
                        updateReviewStep(4, 'completed');
                        updateReviewStep(5, 'completed');
                        await new Promise(resolve => setTimeout(resolve, 500));
                        clearVerboseReviewLoading();
                        showReviewModal('AI Artifacts Review', cachedResult);
                        return;
                    }
                }
                
                updateReviewStep(0, 'completed');
                updateReviewStep(1, 'active');
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // OPTIMIZATION: Batch process all sections in a single API call
                const allContent = sections.map(section => 
                    `## ${section.title}\n${section.content}`
                ).join('\n\n');

                // Get client's AI artifacts or use default
                const clientAIArtifacts = workflowConfig.clientId && CLIENT_DATA[workflowConfig.clientId]?.aiArtifacts 
                    ? CLIENT_DATA[workflowConfig.clientId].aiArtifacts 
                    : CODIFIED_AI_ARTIFACTS;

                const prompt = `Review this article for AI-generated patterns and artifacts. Identify specific phrases, structures, or language patterns that sound artificial or overly formal.

ARTICLE CONTENT:
${allContent}

# AI Artifacts to Avoid (Client-Specific)

${clientAIArtifacts}

For each section, provide:
1. Overall naturalness score (1-10)
2. Key AI artifacts found
3. Specific improvements needed
4. Copy-paste feedback for regeneration

Format as:
# AI ARTIFACTS REVIEW

## OVERALL ASSESSMENT
[Brief overall naturalness score and main issues]

## SECTION-BY-SECTION ANALYSIS

${sections.map(s => `### ${s.title.toUpperCase()}
**Naturalness Score:** [X/10]
**Key Issues:** [Main AI patterns found]
**Improvements:** [Specific suggestions]
**Copy-Paste Feedback:** [Concise feedback for regeneration]`).join('\n\n')}

## SUMMARY
[Key takeaways and priority fixes]

Be concise but thorough. Focus on the most obvious AI patterns.`;

                const review = await callOpenAI(workflowConfig.apiKey, prompt);
                
                updateReviewStep(0, 'completed');
                updateReviewStep(1, 'active');
                await new Promise(resolve => setTimeout(resolve, 200));
                
                updateReviewStep(1, 'completed');
                updateReviewStep(2, 'active');
                await new Promise(resolve => setTimeout(resolve, 200));
                
                updateReviewStep(2, 'completed');
                updateReviewStep(3, 'active');
                await new Promise(resolve => setTimeout(resolve, 200));
                
                updateReviewStep(3, 'completed');
                updateReviewStep(4, 'active');
                await new Promise(resolve => setTimeout(resolve, 200));
                
                updateReviewStep(4, 'completed');
                updateReviewStep(5, 'active');
                
                // OPTIMIZATION: Cache the result
                updateContentCache(sections, 'aiArtifacts', review);
                
                updateReviewStep(5, 'completed');
                updateReviewStep(6, 'active');
                await new Promise(resolve => setTimeout(resolve, 200));
                
                updateReviewStep(6, 'completed');
                await new Promise(resolve => setTimeout(resolve, 300));
                
                clearVerboseReviewLoading();
                showReviewModal('AI Artifacts Review', review);
                
            } catch (error) {
                alert(`Error performing AI artifacts review: ${error.message}`);
                clearVerboseReviewLoading();
            } finally {
                // Re-enable button
                const button = document.getElementById('aiArtifactsReviewBtn');
                if (button) {
                    button.classList.remove('loading');
                    button.disabled = false;
                }
            }
        }

        // Set verbose review loading with progress steps
        function setVerboseReviewLoading(buttonId, title, steps) {
            console.log('Creating verbose review modal with', steps.length, 'steps');
            
            // Disable the button
            const button = document.getElementById(buttonId);
            if (button) {
                button.classList.add('loading');
                button.disabled = true;
            }
            
            // Remove any existing modal
            const existingModal = document.getElementById('verboseReviewModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // Create modal container
            const modal = document.createElement('div');
            modal.id = 'verboseReviewModal';
            modal.className = 'modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 1000;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 20px;
            `;
            
            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 15px;
                padding: 30px;
                max-width: 600px;
                width: 100%;
                box-shadow: 0 20px 40px rgba(0,0,0,0.3);
                position: relative;
            `;
            
            // Create title
            const titleElement = document.createElement('h2');
            titleElement.textContent = title;
            titleElement.style.cssText = `
                margin: 0 0 10px 0;
                color: #1f2937;
                font-size: 1.5rem;
            `;
            
            // Create subtitle
            const subtitleElement = document.createElement('p');
            subtitleElement.textContent = 'Processing your content...';
            subtitleElement.style.cssText = `
                margin: 0 0 30px 0;
                color: #6b7280;
                font-size: 1rem;
            `;
            
            // Create steps container
            const stepsContainer = document.createElement('div');
            stepsContainer.id = 'reviewStepsContainer';
            stepsContainer.style.cssText = `
                display: flex;
                flex-direction: column;
                gap: 15px;
            `;
            
            // Create each step
            steps.forEach((stepText, index) => {
                const stepElement = document.createElement('div');
                stepElement.id = `review-step-${index}`;
                stepElement.setAttribute('data-step', index);
                stepElement.className = 'review-step';
                stepElement.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 15px;
                    padding: 15px;
                    border-radius: 8px;
                    background: #f8fafc;
                    border: 1px solid #e2e8f0;
                    transition: all 0.3s ease;
                `;
                
                // Create step indicator
                const indicator = document.createElement('div');
                indicator.id = `step-indicator-${index}`;
                indicator.className = 'step-indicator';
                indicator.style.cssText = `
                    width: 32px;
                    height: 32px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-weight: bold;
                    font-size: 14px;
                    background: #e5e7eb;
                    color: #6b7280;
                    flex-shrink: 0;
                `;
                indicator.textContent = index + 1;
                
                // Create step text
                const textElement = document.createElement('div');
                textElement.id = `step-text-${index}`;
                textElement.className = 'step-text';
                textElement.textContent = stepText;
                textElement.style.cssText = `
                    color: #6b7280;
                    font-size: 14px;
                    line-height: 1.4;
                `;
                
                stepElement.appendChild(indicator);
                stepElement.appendChild(textElement);
                stepsContainer.appendChild(stepElement);
            });
            
            // Create footer message
            const footerElement = document.createElement('div');
            footerElement.textContent = 'This may take a few moments...';
            footerElement.style.cssText = `
                margin-top: 20px;
                text-align: center;
                color: #9ca3af;
                font-size: 14px;
                font-style: italic;
            `;
            
            // Assemble modal
            modalContent.appendChild(titleElement);
            modalContent.appendChild(subtitleElement);
            modalContent.appendChild(stepsContainer);
            modalContent.appendChild(footerElement);
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            console.log('Modal created with', steps.length, 'steps');
        }
        
        // Clear verbose review loading
        function clearVerboseReviewLoading() {
            const modal = document.getElementById('verboseReviewModal');
            if (modal) {
                modal.remove();
            }
        }

        // Update review step with reliable element targeting
        function updateReviewStep(stepIndex, status = 'active') {
            console.log(`Updating step ${stepIndex} to ${status}`);
            
            // Use unique IDs for reliable element targeting
            const stepElement = document.getElementById(`review-step-${stepIndex}`);
            const indicatorElement = document.getElementById(`step-indicator-${stepIndex}`);
            const textElement = document.getElementById(`step-text-${stepIndex}`);
            
            if (!stepElement) {
                console.error(`Step element ${stepIndex} not found`);
                return;
            }
            
            if (!indicatorElement) {
                console.error(`Indicator element ${stepIndex} not found`);
                return;
            }
            
            if (!textElement) {
                console.error(`Text element ${stepIndex} not found`);
                return;
            }
            
            console.log(`Found all elements for step ${stepIndex}, updating...`);
            
            // Update step background and border
            stepElement.style.background = status === 'active' ? '#dbeafe' : 
                                         status === 'completed' ? '#d1fae5' : '#f8fafc';
            stepElement.style.borderColor = status === 'active' ? '#3b82f6' : 
                                           status === 'completed' ? '#10b981' : '#e2e8f0';
            
            // Update indicator
            if (status === 'completed') {
                indicatorElement.innerHTML = '';
                indicatorElement.style.background = '#10b981';
                indicatorElement.style.color = 'white';
                indicatorElement.style.animation = 'none';
            } else if (status === 'active') {
                indicatorElement.innerHTML = '';
                indicatorElement.style.background = '#3b82f6';
                indicatorElement.style.color = 'white';
                indicatorElement.style.animation = 'pulse 2s infinite';
            } else {
                indicatorElement.innerHTML = stepIndex + 1;
                indicatorElement.style.background = '#e5e7eb';
                indicatorElement.style.color = '#6b7280';
                indicatorElement.style.animation = 'none';
            }
            
            // Update text color
            if (status === 'completed') {
                textElement.style.color = '#10b981';
                textElement.style.fontWeight = '500';
            } else if (status === 'active') {
                textElement.style.color = '#3b82f6';
                textElement.style.fontWeight = '600';
            } else {
                textElement.style.color = '#6b7280';
                textElement.style.fontWeight = '400';
            }
            
            console.log(`Step ${stepIndex} updated to ${status}`);
        }

        async function fixAIArtifactsInSection(sectionTitle, sectionContent) {
            try {
                const prompt = `Fix AI-generated patterns in this section by replacing artificial phrases with natural, human-like alternatives.

SECTION: ${sectionTitle}
CONTENT: ${sectionContent}

# AI Artifacts to Avoid

## 1. Generic opening phrases
Avoid formulaic intros that signal templated content:
- "In this digital age"
- "In today's world"
- "It's worth noting"
- "At its core"
- "In the realm of"
- "In the landscape of"
- "Ever wondered?"
- "Let's delve into"

## 2. Overly formal transitions
Replace stiff connectors with natural flow:
- "Furthermore"
- "Moreover"
- "Additionally"
- "In conclusion"
- "To summarize"
- "It should be noted"

## 3. Redundant phrases
Cut padding phrases that add no real meaning:
- "It's important to note that"
- "It's worth mentioning"
- "It's crucial to understand"
- "It's essential to recognize"
- "Knowledge is power"

## 4. Generic conclusions
Avoid vague, non-specific endings:
- "The future looks bright"
- "Only time will tell"
- "The possibilities are endless"
- "The sky's the limit"
- "Unlock your potential"

## 5. Overly enthusiastic or clich language
Be confident but not breathless:
- "amazing"
- "incredible"
- "revolutionary"
- "game-changing"
- "groundbreaking"
- "microscopic superheroes"
- "robust warriors"
- "efficiency unleashed"

## 6. AI-typical sentence patterns
- **Repetitive structures:** Sentences of similar length and rhythm back-to-back.  
- **Predictable transitions:** "On the other hand," "In a nutshell," "Remember" used formulaically.  
- **Overly comprehensive sweeps:** Covering every possible angle in a neat outline (definition  ranges  lifestyle tips  product shopping) without leaving gaps or distinct POV.  
- **Echoing common phrases:** "Architect of your health," "unlock potential," "master your health" repeated across sections.  
- **Lack of voice drift:** Entire piece maintains the same polished cadence; no variation in tone, sentence fragments, or more human-like asides.  
- **Overloaded adjectives:** Stacking descriptors ("intriguing," "pivotal," "comprehensive," "vital") in one section.  
- **Labored clarity:** Explaining obvious concepts in multiple ways (e.g., "lymphocytes fight infections" repeated 34 times).  

---

## 7. How to Humanize Content
- **Vary rhythm:** Mix short punchy sentences with longer ones. Use fragments when natural.  
- **Inject idiosyncrasy:** Add metaphors or real-world analogies that reflect Function's POV (e.g., "Think of lymphocytes as bouncers at a crowded concert").  
- **Leave edges:** Don't over-polish; allow space for nuance, uncertainty, or perspective.  
- **Avoid wellness clichs:** Replace "wellness journey" with "100 healthy years" or "whole-body view."  
- **Be concise:** Cut inspirational fluff. Say it directly.  

Make the content sound natural and human-written while preserving the original meaning and information.

${getKeywordPrompt()}

IMPORTANT: Only return the improved content. Do NOT include any instructions, guidelines, or meta-text in your response.`;

                const response = await callOpenAI(workflowConfig.apiKey, prompt);
                
                // Clean the response to remove any prompt text that might have leaked through
                let cleanedContent = response.trim();
                
                // Remove common prompt artifacts that might appear
                const promptArtifacts = [
                    'Fix AI-generated patterns in this section',
                    'Replace these common AI artifacts',
                    'Make the content sound natural',
                    'Return the improved content',
                    'IMPORTANT: Only return the improved content',
                    'Do NOT include any instructions',
                    'Do NOT include any guidelines',
                    'Do NOT include any meta-text'
                ];
                
                promptArtifacts.forEach(artifact => {
                    cleanedContent = cleanedContent.replace(new RegExp(artifact, 'gi'), '');
                });
                
                // Remove any remaining instruction text patterns
                cleanedContent = cleanedContent.replace(/^.*?(?=##|#|\w)/s, '').trim();
                
                return cleanedContent || sectionContent; // Fallback to original if cleaning failed
                
            } catch (error) {
                console.error(`Error fixing AI artifacts in section ${sectionTitle}:`, error);
                return sectionContent; // Return original content if fixing fails
            }
        }

        function showReviewModalWithAIFixes(title, content, sectionReviews) {
            // Create modal overlay
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 1000;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 20px;
            `;

            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 15px;
                padding: 30px;
                max-width: 900px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 20px 40px rgba(0,0,0,0.3);
                position: relative;
            `;

            // Create close button
            const closeButton = document.createElement('button');
            closeButton.innerHTML = '';
            closeButton.style.cssText = `
                position: absolute;
                top: 15px;
                right: 15px;
                background: #f3f4f6;
                border: none;
                border-radius: 50%;
                width: 30px;
                height: 30px;
                cursor: pointer;
                font-size: 16px;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            // Create title
            const titleElement = document.createElement('h2');
            titleElement.textContent = title;
            titleElement.style.cssText = `
                margin: 0 0 20px 0;
                color: #1f2937;
                font-size: 1.5rem;
            `;

            // Create content with enhanced formatting
            const contentElement = document.createElement('div');
            contentElement.style.cssText = `
                font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                font-size: 0.9rem;
                line-height: 1.6;
                color: #374151;
                margin-bottom: 20px;
            `;

            // Process content to add Apply Feedback buttons
            const processedContent = content.replace(/\n/g, '<br>');
            contentElement.innerHTML = processedContent;

            // Create Apply Feedback section
            const applySection = document.createElement('div');
            applySection.style.cssText = `
                border-top: 2px solid #e5e7eb;
                padding-top: 20px;
                margin-top: 20px;
            `;

            const applyTitle = document.createElement('h3');
            applyTitle.textContent = 'Apply Feedback to Sections';
            applyTitle.style.cssText = `
                margin: 0 0 15px 0;
                color: #1f2937;
                font-size: 1.2rem;
            `;

            const applyDescription = document.createElement('p');
            applyDescription.textContent = 'Click the buttons below to automatically apply feedback to specific sections:';
            applyDescription.style.cssText = `
                margin: 0 0 15px 0;
                color: #6b7280;
                font-size: 0.9rem;
            `;

            // Get all sections from the current article
            const sections = collectAllSections();
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                margin-bottom: 20px;
            `;

            // Create buttons for each section
            sections.forEach(section => {
                const feedback = extractSectionFeedback(content, section.title);
                if (feedback) {
                    const button = document.createElement('button');
                    button.textContent = `Apply to ${section.title}`;
                    button.style.cssText = `
                        background: #3b82f6;
                        color: white;
                        border: none;
                        border-radius: 6px;
                        padding: 8px 16px;
                        cursor: pointer;
                        font-size: 0.85rem;
                        transition: background-color 0.2s;
                    `;
                    
                    button.onmouseover = () => button.style.background = '#2563eb';
                    button.onmouseout = () => button.style.background = '#3b82f6';
                    
                    button.onclick = () => {
                        // Find the corresponding section ID
                        let sectionId = null;
                        
                        // Check if it's a dynamic section
                        const dynamicSections = document.querySelectorAll('[data-section]');
                        for (const dynSection of dynamicSections) {
                            const sectionTitle = dynSection.querySelector('h4').textContent;
                            if (sectionTitle === section.title) {
                                sectionId = dynSection.getAttribute('data-section');
                                break;
                            }
                        }
                        
                        // If not found in dynamic sections, check static sections
                        if (!sectionId) {
                            if (section.title.toLowerCase().includes('introduction')) {
                                sectionId = 'introduction';
                            } else if (section.title.toLowerCase().includes('conclusion')) {
                                sectionId = 'conclusion';
                            } else {
                                // Try to match with static sections
                                for (let i = 1; i <= 6; i++) {
                                    const staticSection = document.getElementById(`section${i}Editor`);
                                    if (staticSection && staticSection.value.includes(section.title)) {
                                        sectionId = `section${i}`;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        if (sectionId) {
                            applyFeedbackToSection(sectionId, feedback);
                            button.textContent = ' Applied';
                            button.style.background = '#10b981';
                            setTimeout(() => {
                                button.textContent = `Apply to ${section.title}`;
                                button.style.background = '#3b82f6';
                            }, 2000);
                        } else {
                            alert(`Could not find section "${section.title}" to apply feedback to.`);
                        }
                    };
                    
                    buttonContainer.appendChild(button);
                }
            });

            // Create "Fix All AI Artifacts" button
            const fixAllButton = document.createElement('button');
            fixAllButton.textContent = 'Fix All AI Artifacts';
            fixAllButton.style.cssText = `
                background: #dc2626;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 12px 24px;
                cursor: pointer;
                font-size: 1rem;
                font-weight: 600;
                transition: background-color 0.2s;
                margin-top: 10px;
            `;
            
            fixAllButton.onmouseover = () => fixAllButton.style.background = '#b91c1c';
            fixAllButton.onmouseout = () => fixAllButton.style.background = '#dc2626';
            
            fixAllButton.onclick = async () => {
                if (!confirm('This will automatically fix AI artifacts in all sections. Continue?')) {
                    return;
                }
                
                fixAllButton.textContent = 'Fixing...';
                fixAllButton.disabled = true;
                
                try {
                    for (const section of sections) {
                        // Find the corresponding section editor
                        let sectionEditor = null;
                        
                        // Check dynamic sections first
                        const dynamicSections = document.querySelectorAll('[data-section]');
                        for (const dynSection of dynamicSections) {
                            const sectionTitle = dynSection.querySelector('h4').textContent;
                            if (sectionTitle === section.title) {
                                sectionEditor = dynSection.querySelector('textarea');
                                break;
                            }
                        }
                        
                        // If not found in dynamic sections, check static sections
                        if (!sectionEditor) {
                            if (section.title.toLowerCase().includes('introduction')) {
                                sectionEditor = document.getElementById('introductionEditor');
                            } else if (section.title.toLowerCase().includes('conclusion')) {
                                sectionEditor = document.getElementById('conclusionEditor');
                            } else {
                                // Try to match with static sections
                                for (let i = 1; i <= 6; i++) {
                                    const staticSection = document.getElementById(`section${i}Editor`);
                                    if (staticSection && staticSection.value.includes(section.title)) {
                                        sectionEditor = staticSection;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        if (sectionEditor) {
                            const improvedContent = await fixAIArtifactsInSection(section.title, section.content);
                            sectionEditor.value = improvedContent;
                            sectionEditor.dispatchEvent(new Event('input', { bubbles: true }));
                        }
                    }
                    
                    fixAllButton.textContent = ' All Fixed!';
                    fixAllButton.style.background = '#10b981';
                    setTimeout(() => {
                        fixAllButton.textContent = 'Fix All AI Artifacts';
                        fixAllButton.style.background = '#dc2626';
                        fixAllButton.disabled = false;
                    }, 3000);
                    
                } catch (error) {
                    console.error('Error fixing AI artifacts:', error);
                    alert('Error fixing AI artifacts. Please try again.');
                    fixAllButton.textContent = 'Fix All AI Artifacts';
                    fixAllButton.style.background = '#dc2626';
                    fixAllButton.disabled = false;
                }
            };

            // Assemble modal
            modalContent.appendChild(closeButton);
            modalContent.appendChild(titleElement);
            modalContent.appendChild(contentElement);
            
            if (sections.length > 0) {
                applySection.appendChild(applyTitle);
                applySection.appendChild(applyDescription);
                applySection.appendChild(buttonContainer);
                applySection.appendChild(fixAllButton);
                modalContent.appendChild(applySection);
            }
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // Close modal functionality
            closeButton.onclick = () => document.body.removeChild(modal);
            modal.onclick = (e) => {
                if (e.target === modal) document.body.removeChild(modal);
            };
        }

        function showClaimsSelectionModal(allClaims, sectionClaims) {
            
            // Handle case when no claims are found
            if (allClaims.length === 0) {
                // Create modal overlay
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.5);
                    z-index: 1000;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    padding: 20px;
                `;

                // Create modal content
                const modalContent = document.createElement('div');
                modalContent.style.cssText = `
                    background: white;
                    border-radius: 15px;
                    padding: 30px;
                    max-width: 500px;
                    box-shadow: 0 20px 40px rgba(0,0,0,0.3);
                    position: relative;
                    text-align: center;
                `;

                // Create close button
                const closeButton = document.createElement('button');
                closeButton.innerHTML = '';
                closeButton.style.cssText = `
                    position: absolute;
                    top: 15px;
                    right: 15px;
                    background: #f3f4f6;
                    border: none;
                    border-radius: 50%;
                    width: 30px;
                    height: 30px;
                    cursor: pointer;
                    font-size: 16px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;

                modalContent.innerHTML = `
                    <h2 style="margin: 0 0 20px 0; color: #1f2937; font-size: 1.5rem;"> No Citations Needed</h2>
                    <p style="margin: 0 0 20px 0; color: #6b7280; font-size: 1rem; line-height: 1.5;">
                        Great news! Your article doesn't contain any specific claims that require citations. 
                        The content appears to be general advice, common knowledge, or subjective opinions 
                        that don't need source verification.
                    </p>
                    <p style="margin: 0 0 20px 0; color: #6b7280; font-size: 0.9rem;">
                        The Fact & Citation Review looks for specific statistics, facts, performance claims, 
                        comparisons, and technical specifications that readers would expect to be backed up with sources.
                    </p>
                    <button onclick="this.closest('.modal').remove()" style="
                        background: #10b981;
                        color: white;
                        border: none;
                        padding: 12px 24px;
                        border-radius: 8px;
                        cursor: pointer;
                        font-size: 1rem;
                        font-weight: 500;
                    ">Got it!</button>
                `;

                closeButton.onclick = () => modal.remove();
                modalContent.appendChild(closeButton);
                modal.className = 'modal';
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
                return;
            }
            
            // Create modal overlay
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 1000;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 20px;
            `;

            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 15px;
                padding: 30px;
                max-width: 900px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 20px 40px rgba(0,0,0,0.3);
                position: relative;
            `;

            // Create close button
            const closeButton = document.createElement('button');
            closeButton.innerHTML = '';
            closeButton.style.cssText = `
                position: absolute;
                top: 15px;
                right: 15px;
                background: #f3f4f6;
                border: none;
                border-radius: 50%;
                width: 30px;
                height: 30px;
                cursor: pointer;
                font-size: 16px;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            // Create title
            const titleElement = document.createElement('h2');
            titleElement.textContent = 'Select Claims to Research';
            titleElement.style.cssText = `
                margin: 0 0 20px 0;
                color: #1f2937;
                font-size: 1.5rem;
            `;

            // Create description
            const descriptionElement = document.createElement('p');
            descriptionElement.textContent = 'Choose which claims you want to research for citations. Uncheck any claims you don\'t want to verify.';
            descriptionElement.style.cssText = `
                margin: 0 0 20px 0;
                color: #6b7280;
                font-size: 0.9rem;
            `;

            // Create claims list
            const claimsContainer = document.createElement('div');
            claimsContainer.style.cssText = `
                margin-bottom: 20px;
            `;

            // Group claims by section
            const claimsBySection = {};
            allClaims.forEach(claim => {
                if (!claimsBySection[claim.section]) {
                    claimsBySection[claim.section] = [];
                }
                claimsBySection[claim.section].push(claim);
            });

            // Create section groups
            Object.keys(claimsBySection).forEach(sectionTitle => {
                const sectionDiv = document.createElement('div');
                sectionDiv.style.cssText = `
                    margin-bottom: 20px;
                    border: 1px solid #e5e7eb;
                    border-radius: 8px;
                    padding: 15px;
                `;

                const sectionHeader = document.createElement('h3');
                sectionHeader.textContent = sectionTitle;
                sectionHeader.style.cssText = `
                    margin: 0 0 15px 0;
                    color: #1f2937;
                    font-size: 1.1rem;
                `;

                const claimsList = document.createElement('div');
                claimsList.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                `;

                claimsBySection[sectionTitle].forEach((claim, index) => {
                    const claimDiv = document.createElement('div');
                    claimDiv.style.cssText = `
                        display: flex;
                        align-items: flex-start;
                        gap: 10px;
                        padding: 10px;
                        background: #f9fafb;
                        border-radius: 6px;
                    `;

                    // Sanitize section title for ID
                    const sanitizedSectionTitle = sectionTitle.replace(/[^a-zA-Z0-9]/g, '');
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = true;
                    checkbox.id = `claim-${sanitizedSectionTitle}-${index}`;
                    checkbox.style.cssText = `
                        margin-top: 2px;
                        flex-shrink: 0;
                        width: 16px;
                        height: 16px;
                    `;

                    const label = document.createElement('label');
                    label.htmlFor = `claim-${sanitizedSectionTitle}-${index}`;
                    label.style.cssText = `
                        flex: 1;
                        font-size: 0.9rem;
                        line-height: 1.4;
                        color: #374151;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                    `;

                    const claimText = document.createElement('span');
                    claimText.textContent = claim.claim;
                    claimText.style.cssText = `
                        flex: 1;
                    `;

                    const typeBadge = document.createElement('span');
                    typeBadge.textContent = claim.type.toUpperCase();
                    typeBadge.style.cssText = `
                        background: ${claim.type === 'claim' ? '#3b82f6' : claim.type === 'statistic' ? '#10b981' : '#f59e0b'};
                        color: white;
                        padding: 2px 6px;
                        border-radius: 4px;
                        font-size: 0.7rem;
                        font-weight: 500;
                        flex-shrink: 0;
                    `;

                    label.appendChild(claimText);
                    label.appendChild(typeBadge);

                    claimDiv.appendChild(checkbox);
                    claimDiv.appendChild(label);
                    claimsList.appendChild(claimDiv);
                    
                    // Store reference to the label and section title on the checkbox for easier access
                    checkbox._label = label;
                    checkbox._sectionTitle = sectionTitle;
                    checkbox._claimText = claim.claim;
                    checkbox._claimType = claim.type;
                });

                sectionDiv.appendChild(sectionHeader);
                sectionDiv.appendChild(claimsList);
                claimsContainer.appendChild(sectionDiv);
            });

            // Create action buttons
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
                display: flex;
                gap: 10px;
                justify-content: flex-end;
                margin-top: 20px;
                padding-top: 20px;
                border-top: 1px solid #e5e7eb;
            `;

            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.style.cssText = `
                background: #6b7280;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 10px 20px;
                cursor: pointer;
                font-size: 0.9rem;
            `;

            const researchButton = document.createElement('button');
            researchButton.textContent = 'Research Selected Claims';
            researchButton.style.cssText = `
                background: #3b82f6;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 10px 20px;
                cursor: pointer;
                font-size: 0.9rem;
            `;

            const researchStatsButton = document.createElement('button');
            researchStatsButton.textContent = 'Research All Statistics';
            researchStatsButton.style.cssText = `
                background: #10b981;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 10px 20px;
                cursor: pointer;
                font-size: 0.9rem;
            `;

            const researchFactsButton = document.createElement('button');
            researchFactsButton.textContent = 'Research All Facts';
            researchFactsButton.style.cssText = `
                background: #3b82f6;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 10px 20px;
                cursor: pointer;
                font-size: 0.9rem;
            `;

            const researchTechButton = document.createElement('button');
            researchTechButton.textContent = 'Research All Technical';
            researchTechButton.style.cssText = `
                background: #f59e0b;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 10px 20px;
                cursor: pointer;
                font-size: 0.9rem;
            `;

            // Assemble modal
            modalContent.appendChild(closeButton);
            modalContent.appendChild(titleElement);
            modalContent.appendChild(descriptionElement);
            modalContent.appendChild(claimsContainer);
            buttonContainer.appendChild(cancelButton);
            buttonContainer.appendChild(researchStatsButton);
            buttonContainer.appendChild(researchFactsButton);
            buttonContainer.appendChild(researchTechButton);
            buttonContainer.appendChild(researchButton);
            modalContent.appendChild(buttonContainer);
            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // Event handlers
            closeButton.onclick = () => document.body.removeChild(modal);
            cancelButton.onclick = () => document.body.removeChild(modal);
            
            // Helper function to get selected claims
            const getSelectedClaims = () => {
                const selectedClaims = [];
                const checkboxes = modalContent.querySelectorAll('input[type="checkbox"]:checked');
                
                checkboxes.forEach(checkbox => {
                    // Use stored data if available (preferred method)
                    if (checkbox._sectionTitle && checkbox._claimText && checkbox._claimType) {
                        selectedClaims.push({
                            claim: checkbox._claimText,
                            section: checkbox._sectionTitle,
                            type: checkbox._claimType
                        });
                        return;
                    }
                    
                    // Fallback to DOM parsing if stored data not available
                    let label = checkbox._label || checkbox.nextElementSibling;
                    
                    if (!label) {
                        return;
                    }
                    
                    const claimTextSpan = label.querySelector('span:first-child');
                    const typeSpan = label.querySelector('span:last-child');
                    
                    // Try multiple ways to find the section header
                    let sectionHeader = null;
                    let sectionDiv = checkbox.closest('div[style*="border: 1px solid #e5e7eb"]');
                    
                    if (sectionDiv) {
                        sectionHeader = sectionDiv.querySelector('h3');
                    }
                    
                    // Fallback: look for h3 in parent containers
                    if (!sectionHeader) {
                        let parent = checkbox.parentElement;
                        while (parent && parent !== modalContent) {
                            const h3 = parent.querySelector('h3');
                            if (h3) {
                                sectionHeader = h3;
                                break;
                            }
                            parent = parent.parentElement;
                        }
                    }
                    
                    if (!claimTextSpan || !typeSpan || !sectionHeader) {
                        return;
                    }
                    
                    const claimText = claimTextSpan.textContent;
                    const sectionTitle = sectionHeader.textContent;
                    const type = typeSpan.textContent.toLowerCase();
                    
                    selectedClaims.push({
                        claim: claimText,
                        section: sectionTitle,
                        type: type
                    });
                });
                
                return selectedClaims;
            };

            // Helper function to select claims by type
            const selectClaimsByType = (type) => {
                const checkboxes = modalContent.querySelectorAll('input[type="checkbox"]');
                
                let selectedCount = 0;
                checkboxes.forEach((checkbox, index) => {
                    // Use stored data if available (preferred method)
                    if (checkbox._claimType) {
                        if (checkbox._claimType === type) {
                            checkbox.checked = true;
                            selectedCount++;
                        }
                        return;
                    }
                    
                    // Fallback to DOM parsing if stored data not available
                    let label = checkbox._label || checkbox.nextElementSibling;
                    
                    if (!label) {
                        return;
                    }
                    
                    const typeSpan = label.querySelector('span:last-child');
                    if (!typeSpan) {
                        return;
                    }
                    
                    const claimType = typeSpan.textContent.toLowerCase();
                    if (claimType === type) {
                        checkbox.checked = true;
                        selectedCount++;
                    }
                });
                
            };

            researchButton.onclick = async () => {
                const selectedClaims = getSelectedClaims();

                if (selectedClaims.length === 0) {
                    alert('Please select at least one claim to research.');
                    return;
                }

                // Close selection modal
                document.body.removeChild(modal);

                // Research selected claims
                await researchSelectedClaims(selectedClaims, sectionClaims);
            };

            researchStatsButton.onclick = async () => {
                // Select all statistics
                selectClaimsByType('statistic');
                
                const selectedClaims = getSelectedClaims();
                
                if (selectedClaims.length === 0) {
                    alert('No statistics found to research.');
                    return;
                }

                // Close selection modal
                document.body.removeChild(modal);

                // Research selected claims
                await researchSelectedClaims(selectedClaims, sectionClaims);
            };

            researchFactsButton.onclick = async () => {
                // Select all facts
                selectClaimsByType('fact');
                
                const selectedClaims = getSelectedClaims();
                
                if (selectedClaims.length === 0) {
                    alert('No facts found to research.');
                    return;
                }

                // Close selection modal
                document.body.removeChild(modal);

                // Research selected claims
                await researchSelectedClaims(selectedClaims, sectionClaims);
            };

            researchTechButton.onclick = async () => {
                // Select all technical claims
                selectClaimsByType('technical');
                
                const selectedClaims = getSelectedClaims();
                
                if (selectedClaims.length === 0) {
                    alert('No technical claims found to research.');
                    return;
                }

                // Close selection modal
                document.body.removeChild(modal);

                // Research selected claims
                await researchSelectedClaims(selectedClaims, sectionClaims);
            };

            modal.onclick = (e) => {
                if (e.target === modal) document.body.removeChild(modal);
            };
        }

        async function researchSelectedClaims(selectedClaims, sectionClaims) {
            try {
                // Validate inputs
                if (!selectedClaims || !Array.isArray(selectedClaims) || selectedClaims.length === 0) {
                    alert('No claims selected for research.');
                    return;
                }
                
                if (!sectionClaims || !Array.isArray(sectionClaims)) {
                    alert('No section claims data available.');
                    return;
                }

                const sectionReviews = [];
                const citationResults = [];
                
                // Group selected claims by section
                const claimsBySection = {};
                selectedClaims.forEach(claim => {
                    if (claim && claim.section) {
                        if (!claimsBySection[claim.section]) {
                            claimsBySection[claim.section] = [];
                        }
                        claimsBySection[claim.section].push(claim);
                    }
                });

                // Calculate total claims and sections for progress tracking
                const totalClaims = selectedClaims.length;
                const sections = Object.keys(claimsBySection);
                
                // Show progress modal
                showCitationProgress(totalClaims, sections);

                // Research each section
                let completedClaims = 0;
                let totalFoundCitations = 0;
                
                for (let i = 0; i < sections.length; i++) {
                    const sectionTitle = sections[i];
                    const sectionClaimData = sectionClaims.find(sc => sc.sectionTitle === sectionTitle);
                    const claimsToResearch = (claimsBySection[sectionTitle] || []).map(c => c.claim).filter(claim => claim);
                    
                    // Update current section
                    updateCitationProgressSection(i);
                    
                    // Show research method selection for this section
                    const researchMethod = await showResearchMethodSelection(claimsToResearch, sectionTitle);
                    
                    let citations = [];
                    if (researchMethod === 'chatgpt') {
                        // Show ChatGPT modal and skip automated research
                        showChatGPTCitationModal(claimsToResearch, sectionTitle);
                        citations = []; // Empty array - user will handle manually
                    } else if (researchMethod === 'automated') {
                        // Show coffee modal and use automated Deep Research
                        showCoffeeModal();
                        citations = await searchForCitations(claimsToResearch, sectionTitle);
                        hideCoffeeModal();
                    } else {
                        // User cancelled
                        return;
                    }
                    
                    // Update progress
                    completedClaims += claimsToResearch.length;
                    totalFoundCitations += citations.length;
                    updateCitationProgressClaim(completedClaims, totalFoundCitations);
                    
                    // Store citation results for inline insertion
                    citationResults.push({
                        sectionTitle: sectionTitle,
                        citations: citations
                    });
                    
                    // Format the review with actual citations
                    const formattedReview = `## ${sectionTitle.toUpperCase()} CITATION REVIEW

### Statistics Needing Sources:
${(sectionClaimData?.statistics || []).map(stat => `- ${stat}`).join('\n')}

### Facts Requiring Verification:
${(sectionClaimData?.facts || []).map(fact => `- ${fact}`).join('\n')}

### Performance Claims:
${(sectionClaimData?.performance || []).map(perf => `- ${perf}`).join('\n')}

### Comparisons:
${(sectionClaimData?.comparisons || []).map(comp => `- ${comp}`).join('\n')}

### Technical Information:
${(sectionClaimData?.technical || []).map(tech => `- ${tech}`).join('\n')}

### Found Citations:
${citations.length > 0 ? citations.map(citation => `
**Claim:** ${citation.claim}
**Source:** ${citation.url ? `[${citation.source}](${citation.url})` : citation.source}
**Author:** ${citation.author}
**Publication:** ${citation.publication}
**Date:** ${citation.date}
**Credibility:** ${citation.relevance}
**Evidence:** ${citation.snippet}
**Academic Citation:** ${citation.citationFormat || `(${citation.author}, ${citation.date})`}
`).join('\n') : 'No citations found for the selected claims.'}

### Copy-Paste Feedback for Regeneration:
${sectionClaimData?.summary || 'No summary available'}

### Recommended Actions:
${citations.length > 0 ? 
    ` ${citations.length} citation(s) found - consider incorporating these sources into your content` : 
    ' No citations found - consider adding more specific, verifiable claims or manually researching sources'}

### Citation Integration Tips:
- Use the provided academic citation format for each source
- Verify the sources and URLs before publishing
- Add in-text citations where claims are made: (Author, Date)
- Include a references section at the end of your article
- Prioritize High credibility sources over Medium/Low
- Check publication dates for currency and relevance
- Consider the author's credentials and publication reputation`;

                    sectionReviews.push({
                        name: sectionTitle,
                        review: formattedReview
                    });
                }

                // Combine all section reviews into one comprehensive report
                const combinedReview = `# FACT & CITATION REVIEW

## OVERVIEW
This review analyzes the selected claims from each section and attempts to find actual sources for verification.

${sectionReviews.map(sr => `\n${sr.review}`).join('\n\n---\n\n')}

## OVERALL ASSESSMENT
Review the individual section analyses above for detailed feedback on each part of your article.`;

                // Show review modal with inline citation options
                showReviewModalWithCitations('Fact & Citation Review', combinedReview, citationResults);
                
                // Hide progress modal
                hideCitationProgress();
                
            } catch (error) {
                alert(`Error researching selected claims: ${error.message}`);
                hideCitationProgress();
            }
        }

        function showReviewModalWithCitations(title, content, citationResults) {
            // Create modal overlay
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 1000;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 20px;
            `;

            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 15px;
                padding: 30px;
                max-width: 900px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 20px 40px rgba(0,0,0,0.3);
                position: relative;
            `;

            // Create close button
            const closeButton = document.createElement('button');
            closeButton.innerHTML = '';
            closeButton.style.cssText = `
                position: absolute;
                top: 15px;
                right: 15px;
                background: #f3f4f6;
                border: none;
                border-radius: 50%;
                width: 30px;
                height: 30px;
                cursor: pointer;
                font-size: 16px;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            // Create title
            const titleElement = document.createElement('h2');
            titleElement.textContent = title;
            titleElement.style.cssText = `
                margin: 0 0 20px 0;
                color: #1f2937;
                font-size: 1.5rem;
            `;

            // Create content
            const contentElement = document.createElement('div');
            contentElement.innerHTML = content.replace(/\n/g, '<br>');
            contentElement.style.cssText = `
                font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                font-size: 0.9rem;
                line-height: 1.6;
                color: #374151;
                margin-bottom: 20px;
            `;

            // Create inline citation section
            const inlineSection = document.createElement('div');
            inlineSection.style.cssText = `
                border-top: 2px solid #e5e7eb;
                padding-top: 20px;
                margin-top: 20px;
            `;

            const inlineTitle = document.createElement('h3');
            inlineTitle.textContent = ' O3 Deep Research Citation Results';
            inlineTitle.style.cssText = `
                margin: 0 0 15px 0;
                color: #059669;
                font-size: 1.2rem;
            `;

            const inlineDescription = document.createElement('div');
            inlineDescription.innerHTML = `
                <p style="margin: 0 0 15px 0; color: #059669; font-size: 0.9rem; font-weight: 600;">
                     Powered by O3 Deep Research - Real sources found and verified
                </p>
                <p style="margin: 0 0 15px 0; color: #6b7280; font-size: 0.9rem;">
                    The system has conducted comprehensive research using OpenAI's O3 Deep Research model 
                    to find credible, verifiable sources for each claim. All sources have been validated for accessibility.
                </p>
                <p style="margin: 0 0 15px 0; color: #374151; font-size: 0.9rem;">
                    <strong>Research Results:</strong><br>
                     Sources verified for accessibility and relevance<br>
                     Academic and authoritative sources prioritized<br>
                     Proper citation formats provided<br>
                     Ready for insertion into your article
                </p>
            `;

            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
            `;

            // Create Insert All Citations button
            const fixAllButton = document.createElement('button');
            fixAllButton.textContent = ' Insert All Verified Citations';
            fixAllButton.style.cssText = `
                background: #059669;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 12px 24px;
                cursor: pointer;
                font-size: 1rem;
                font-weight: 600;
                transition: background-color 0.2s;
                margin-bottom: 15px;
                width: 100%;
            `;
            
            fixAllButton.onmouseover = () => fixAllButton.style.background = '#047857';
            fixAllButton.onmouseout = () => fixAllButton.style.background = '#059669';
            
            fixAllButton.onclick = () => {
                let insertedCount = 0;
                let totalCount = 0;
                let totalVerifiedCitations = 0;
                let totalCitations = 0;
                
                citationResults.forEach(result => {
                    if (result.citations.length > 0) {
                        totalCount++;
                        totalCitations += result.citations.length;
                        
                        // Insert verified citations
                        const verifiedCitations = result.citations.filter(c => 
                            c.verified && c.validationStatus && c.validationStatus.includes('Accessible')
                        );
                        
                        if (verifiedCitations.length > 0) {
                            insertCitationsIntoSection(result.sectionTitle, verifiedCitations);
                            insertedCount++;
                            totalVerifiedCitations += verifiedCitations.length;
                        }
                    }
                });
                
                // Add global references section
                insertGlobalReferencesSection();
                
                fixAllButton.textContent = ` Inserted ${totalVerifiedCitations}/${totalCitations} verified citations in ${insertedCount}/${totalCount} sections`;
                fixAllButton.style.background = '#10b981';
                
                setTimeout(() => {
                    fixAllButton.textContent = ' Insert All Verified Citations';
                    fixAllButton.style.background = '#059669';
                }, 3000);
            };
            
            buttonContainer.appendChild(fixAllButton);

            // Create buttons for each section with citations
            citationResults.forEach(result => {
                if (result.citations.length > 0) {
                    const verifiedCount = result.citations.filter(c => c.verified && c.validationStatus && c.validationStatus.includes('Accessible')).length;
                    const totalCount = result.citations.length;
                    
                    const button = document.createElement('button');
                    button.textContent = ` Insert Citations in ${result.sectionTitle} (${verifiedCount}/${totalCount} verified)`;
                    button.style.cssText = `
                        background: ${verifiedCount === totalCount ? '#059669' : verifiedCount > 0 ? '#f59e0b' : '#dc2626'};
                        color: white;
                        border: none;
                        border-radius: 6px;
                        padding: 8px 16px;
                        cursor: pointer;
                        font-size: 0.85rem;
                        transition: background-color 0.2s;
                        position: relative;
                    `;
                    
                    // Add validation status tooltip
                    const tooltip = document.createElement('div');
                    tooltip.style.cssText = `
                        position: absolute;
                        bottom: 100%;
                        left: 50%;
                        transform: translateX(-50%);
                        background: #1f2937;
                        color: white;
                        padding: 8px 12px;
                        border-radius: 4px;
                        font-size: 0.75rem;
                        white-space: nowrap;
                        opacity: 0;
                        pointer-events: none;
                        transition: opacity 0.2s;
                        z-index: 1000;
                        margin-bottom: 5px;
                    `;
                    
                    const sourceDetails = result.citations.map(c => {
                        const status = c.verified ? '' : '';
                        return `${status} ${c.source.substring(0, 30)}...`;
                    }).join('\n');
                    
                    tooltip.textContent = `Research Results:\n${sourceDetails}`;
                    button.appendChild(tooltip);
                    
                    button.onmouseover = () => {
                        button.style.background = verifiedCount === totalCount ? '#047857' : verifiedCount > 0 ? '#d97706' : '#b91c1c';
                        tooltip.style.opacity = '1';
                    };
                    button.onmouseout = () => {
                        button.style.background = verifiedCount === totalCount ? '#059669' : verifiedCount > 0 ? '#f59e0b' : '#dc2626';
                        tooltip.style.opacity = '0';
                    };
                    
                    button.onclick = () => {
                        // Insert verified citations for this section
                        const verifiedCitations = result.citations.filter(c => 
                            c.verified && c.validationStatus && c.validationStatus.includes('Accessible')
                        );
                        
                        if (verifiedCitations.length > 0) {
                            insertCitationsIntoSection(result.sectionTitle, verifiedCitations);
                            insertGlobalReferencesSection();
                            button.textContent = ` ${verifiedCitations.length} Citations Inserted`;
                            button.style.background = '#10b981';
                        } else {
                            alert('No verified citations available for this section. All sources failed validation or require manual research.');
                        }
                        
                        setTimeout(() => {
                            button.textContent = ` Insert Citations in ${result.sectionTitle} (${verifiedCount}/${totalCount} verified)`;
                            button.style.background = verifiedCount === totalCount ? '#059669' : verifiedCount > 0 ? '#f59e0b' : '#dc2626';
                        }, 3000);
                    };
                    
                    buttonContainer.appendChild(button);
                }
            });

            // Assemble modal
            modalContent.appendChild(closeButton);
            modalContent.appendChild(titleElement);
            modalContent.appendChild(contentElement);
            
            if (citationResults.some(result => result.citations.length > 0)) {
                inlineSection.appendChild(inlineTitle);
                inlineSection.appendChild(inlineDescription);
                inlineSection.appendChild(buttonContainer);
                modalContent.appendChild(inlineSection);
            }
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // Close modal functionality
            closeButton.onclick = () => document.body.removeChild(modal);
            modal.onclick = (e) => {
                if (e.target === modal) document.body.removeChild(modal);
            };
        }

        // Global citation tracking
        let globalCitationCounter = 0;
        let globalCitations = [];

        function resetGlobalCitations() {
            globalCitationCounter = 0;
            globalCitations = [];
        }

        function insertCitationsIntoSection(sectionTitle, citations) {
            // Find the section editor
            let sectionEditor = null;
            
            // Check dynamic sections first
            const dynamicSections = document.querySelectorAll('[data-section]');
            for (const dynSection of dynamicSections) {
                const sectionTitleElement = dynSection.querySelector('h4');
                if (sectionTitleElement && sectionTitleElement.textContent === sectionTitle) {
                    sectionEditor = dynSection.querySelector('textarea');
                    break;
                }
            }
            
            // If not found in dynamic sections, check static sections
            if (!sectionEditor) {
                if (sectionTitle.toLowerCase().includes('introduction')) {
                    sectionEditor = document.getElementById('introductionEditor');
                } else if (sectionTitle.toLowerCase().includes('conclusion')) {
                    sectionEditor = document.getElementById('conclusionEditor');
                } else {
                    // Try to match with static sections
                    for (let i = 1; i <= 6; i++) {
                        const staticSection = document.getElementById(`section${i}Editor`);
                        if (staticSection && staticSection.value.includes(sectionTitle)) {
                            sectionEditor = staticSection;
                            break;
                        }
                    }
                }
            }
            
            if (!sectionEditor) {
                alert(`Could not find section "${sectionTitle}" to insert citations into.`);
                return;
            }
            
            let content = sectionEditor.value;
            
            // Filter citations to only include the most important ones
            const filteredCitations = filterImportantCitations(citations);
            
            // Insert citations for each claim (limit to 2-3 per section)
            filteredCitations.slice(0, 3).forEach((citation) => {
                const claim = citation.claim;
                
                // Check if this citation already exists globally
                let existingCitation = globalCitations.find(gc => 
                    gc.source === citation.source && 
                    gc.url === citation.url && 
                    gc.author === citation.author
                );
                
                let citationNumber;
                if (existingCitation) {
                    // Use existing citation number
                    citationNumber = existingCitation.globalNumber;
                } else {
                    // Add new citation to global list
                    globalCitationCounter++;
                    citationNumber = globalCitationCounter;
                    globalCitations.push({
                        ...citation,
                        globalNumber: citationNumber
                    });
                }
                
                // Create inline citation format
                const citationText = `[${citationNumber}]`;
                
                // Find the claim in the content and add citation
                const claimRegex = new RegExp(`(${claim.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                content = content.replace(claimRegex, `$1${citationText}`);
            });
            
            // Update the editor content
            sectionEditor.value = content;
            
            // Trigger change event to mark as modified
            sectionEditor.dispatchEvent(new Event('input', { bubbles: true }));
            
        }

        function insertGlobalReferencesSection() {
            // Find the conclusion section to add references after it
            let conclusionEditor = document.getElementById('conclusionEditor');
            if (!conclusionEditor || !conclusionEditor.value.trim()) {
                // If no conclusion, find the last section with content
                const allEditors = [
                    document.getElementById('introductionEditor'),
                    ...Array.from({length: 6}, (_, i) => document.getElementById(`section${i+1}Editor`)),
                    document.getElementById('conclusionEditor')
                ].filter(editor => editor && editor.value.trim());
                
                if (allEditors.length > 0) {
                    conclusionEditor = allEditors[allEditors.length - 1];
                }
            }
            
            if (!conclusionEditor) {
                return;
            }
            
            let content = conclusionEditor.value;
            
            // Remove any existing References section
            content = content.replace(/\n\n## References[\s\S]*$/, '');
            
            // Add global references section
            if (globalCitations.length > 0) {
                const referencesSection = createGlobalReferencesSection(globalCitations);
                content += `\n\n## References\n\n${referencesSection}`;
                
                // Update the editor content
                conclusionEditor.value = content;
                conclusionEditor.dispatchEvent(new Event('input', { bubbles: true }));
                
            }
        }

        function createGlobalReferencesSection(citations) {
            // Sort citations by their global number
            const sortedCitations = citations.sort((a, b) => a.globalNumber - b.globalNumber);
            
            return sortedCitations.map((citation) => {
                const citationNumber = citation.globalNumber;
                const source = citation.source;
                const url = citation.url;
                const author = citation.author;
                const date = citation.date;
                const publication = citation.publication || '';
                
                // Format in APA style: Author, A. A. (Year). Title. Publication. URL
                let formattedCitation = `[${citationNumber}] `;
                
                if (author && author !== 'Unknown') {
                    // Format author name (Last, F. M.)
                    const authorParts = author.split(' ');
                    if (authorParts.length >= 2) {
                        const lastName = authorParts[authorParts.length - 1];
                        const firstInitials = authorParts.slice(0, -1).map(name => name.charAt(0).toUpperCase() + '.').join(' ');
                        formattedCitation += `${lastName}, ${firstInitials}`;
                    } else {
                        formattedCitation += author;
                    }
                }
                
                if (date && date !== 'Unknown') {
                    formattedCitation += ` (${date})`;
                }
                
                if (source) {
                    formattedCitation += `. ${source}`;
                }
                
                if (publication && publication !== 'Unknown') {
                    formattedCitation += `. ${publication}`;
                }
                
                if (url) {
                    formattedCitation += `. Retrieved from ${url}`;
                }
                
                return formattedCitation;
            }).join('\n\n');
        }

        function filterImportantCitations(citations) {
            // Filter citations based on importance criteria
            return citations.filter(citation => {
                // Prioritize high credibility sources
                if (citation.relevance === 'High') return true;
                
                // Include statistics and technical claims (more important to cite)
                if (citation.claim.toLowerCase().includes('percent') || 
                    citation.claim.toLowerCase().includes('study') ||
                    citation.claim.toLowerCase().includes('research') ||
                    citation.claim.toLowerCase().includes('data') ||
                    citation.claim.toLowerCase().includes('algorithm') ||
                    citation.claim.toLowerCase().includes('technology')) {
                    return true;
                }
                
                // Include claims with academic sources
                if (citation.url && (citation.url.includes('.edu') || citation.url.includes('.org'))) {
                    return true;
                }
                
                return false;
            }).sort((a, b) => {
                // Sort by importance: High credibility first, then by source type
                if (a.relevance === 'High' && b.relevance !== 'High') return -1;
                if (b.relevance === 'High' && a.relevance !== 'High') return 1;
                return 0;
            });
        }

        function createReferencesSection(citations) {
            return citations.map((citation, index) => {
                const citationNumber = index + 1;
                const source = citation.source;
                const url = citation.url;
                const author = citation.author;
                const date = citation.date;
                
                if (url) {
                    return `[${citationNumber}] [${source}](${url})`;
                } else {
                    return `[${citationNumber}] ${source} (${author}, ${date})`;
                }
            }).join('\n\n');
        }

        // Function to extract feedback for a specific section from review content
        function extractSectionFeedback(reviewContent, sectionTitle) {
            // Look for the section's review in the content
            const sectionPattern = new RegExp(`## ${sectionTitle.toUpperCase()}[\\s\\S]*?(?=##|$)`, 'i');
            const sectionMatch = reviewContent.match(sectionPattern);
            
            if (!sectionMatch) {
                return null;
            }
            
            const sectionReview = sectionMatch[0];
            
            // Extract copy-paste feedback if available
            const copyPasteMatch = sectionReview.match(/### Copy-Paste Feedback for Regeneration:\s*\[([^\]]+)\]/);
            if (copyPasteMatch) {
                return copyPasteMatch[1];
            }
            
            // If no copy-paste feedback, extract key issues and suggestions
            const issuesMatch = sectionReview.match(/### Issues Found:([\\s\\S]*?)(?=###|$)/);
            const suggestionsMatch = sectionReview.match(/### (?:Suggestions|Recommendations):([\\s\\S]*?)(?=###|$)/);
            
            let feedback = '';
            if (issuesMatch) {
                feedback += 'Issues: ' + issuesMatch[1].trim() + ' ';
            }
            if (suggestionsMatch) {
                feedback += 'Suggestions: ' + suggestionsMatch[1].trim();
            }
            
            return feedback.trim() || 'No specific feedback available';
        }

        // Function to apply feedback to a section
        function applyFeedbackToSection(sectionId, feedback) {
            const feedbackInput = document.getElementById(`${sectionId}Feedback`);
            if (feedbackInput) {
                feedbackInput.value = feedback;
                // Trigger regeneration
                regenerateSection(sectionId);
            }
        }

        function showReviewModal(title, content) {
            // Create modal overlay
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 1000;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 20px;
            `;

            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 15px;
                padding: 30px;
                max-width: 900px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 20px 40px rgba(0,0,0,0.3);
                position: relative;
            `;

            // Create close button
            const closeButton = document.createElement('button');
            closeButton.innerHTML = '';
            closeButton.style.cssText = `
                position: absolute;
                top: 15px;
                right: 15px;
                background: #f3f4f6;
                border: none;
                border-radius: 50%;
                width: 30px;
                height: 30px;
                cursor: pointer;
                font-size: 16px;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            // Create title
            const titleElement = document.createElement('h2');
            titleElement.textContent = title;
            titleElement.style.cssText = `
                margin: 0 0 20px 0;
                color: #1f2937;
                font-size: 1.5rem;
            `;

            // Create content with enhanced formatting
            const contentElement = document.createElement('div');
            contentElement.style.cssText = `
                font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                font-size: 0.9rem;
                line-height: 1.6;
                color: #374151;
                margin-bottom: 20px;
            `;

            // Process content to add Apply Feedback buttons
            const processedContent = content.replace(/\n/g, '<br>');
            contentElement.innerHTML = processedContent;

            // Create Apply Feedback section
            const applySection = document.createElement('div');
            applySection.style.cssText = `
                border-top: 2px solid #e5e7eb;
                padding-top: 20px;
                margin-top: 20px;
            `;

            const applyTitle = document.createElement('h3');
            applyTitle.textContent = 'Apply Feedback to Sections';
            applyTitle.style.cssText = `
                margin: 0 0 15px 0;
                color: #1f2937;
                font-size: 1.2rem;
            `;

            const applyDescription = document.createElement('p');
            applyDescription.textContent = 'Click the buttons below to automatically apply feedback to specific sections:';
            applyDescription.style.cssText = `
                margin: 0 0 15px 0;
                color: #6b7280;
                font-size: 0.9rem;
            `;

            // Get all sections from the current article
            const sections = collectAllSections();
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
            `;

            // Create Fix All Issues button
            const fixAllButton = document.createElement('button');
            fixAllButton.textContent = ' Fix All Issues';
            fixAllButton.style.cssText = `
                background: #28a745;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 12px 24px;
                cursor: pointer;
                font-size: 1rem;
                font-weight: 600;
                transition: background-color 0.2s;
                margin-bottom: 15px;
                width: 100%;
            `;
            
            fixAllButton.onmouseover = () => fixAllButton.style.background = '#218838';
            fixAllButton.onmouseout = () => fixAllButton.style.background = '#28a745';
            
            fixAllButton.onclick = () => {
                let appliedCount = 0;
                let totalCount = 0;
                
                sections.forEach(section => {
                    const feedback = extractSectionFeedback(content, section.title);
                    if (feedback) {
                        totalCount++;
                        
                        // Find the corresponding section ID
                        let sectionId = null;
                        
                        // Check if it's a dynamic section
                        const dynamicSections = document.querySelectorAll('[data-section]');
                        for (const dynSection of dynamicSections) {
                            const sectionTitle = dynSection.querySelector('h4').textContent;
                            if (sectionTitle === section.title) {
                                sectionId = dynSection.getAttribute('data-section');
                                break;
                            }
                        }
                        
                        // If not found in dynamic sections, check static sections
                        if (!sectionId) {
                            if (section.title.toLowerCase().includes('introduction')) {
                                sectionId = 'introduction';
                            } else if (section.title.toLowerCase().includes('conclusion')) {
                                sectionId = 'conclusion';
                            } else {
                                // Try to match with static sections
                                for (let i = 1; i <= 6; i++) {
                                    const staticSection = document.getElementById(`section${i}Editor`);
                                    if (staticSection && staticSection.value.includes(section.title)) {
                                        sectionId = `section${i}`;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        if (sectionId) {
                            applyFeedbackToSection(sectionId, feedback);
                            appliedCount++;
                        }
                    }
                });
                
                fixAllButton.textContent = ` Applied to ${appliedCount}/${totalCount} sections`;
                fixAllButton.style.background = '#10b981';
                
                setTimeout(() => {
                    fixAllButton.textContent = ' Fix All Issues';
                    fixAllButton.style.background = '#28a745';
                }, 3000);
            };
            
            buttonContainer.appendChild(fixAllButton);

            // Create buttons for each section
            sections.forEach(section => {
                const feedback = extractSectionFeedback(content, section.title);
                if (feedback) {
                    const button = document.createElement('button');
                    button.textContent = `Apply to ${section.title}`;
                    button.style.cssText = `
                        background: #3b82f6;
                        color: white;
                        border: none;
                        border-radius: 6px;
                        padding: 8px 16px;
                        cursor: pointer;
                        font-size: 0.85rem;
                        transition: background-color 0.2s;
                    `;
                    
                    button.onmouseover = () => button.style.background = '#2563eb';
                    button.onmouseout = () => button.style.background = '#3b82f6';
                    
                    button.onclick = () => {
                        // Find the corresponding section ID
                        let sectionId = null;
                        
                        // Check if it's a dynamic section
                        const dynamicSections = document.querySelectorAll('[data-section]');
                        for (const dynSection of dynamicSections) {
                            const sectionTitle = dynSection.querySelector('h4').textContent;
                            if (sectionTitle === section.title) {
                                sectionId = dynSection.getAttribute('data-section');
                                break;
                            }
                        }
                        
                        // If not found in dynamic sections, check static sections
                        if (!sectionId) {
                            if (section.title.toLowerCase().includes('introduction')) {
                                sectionId = 'introduction';
                            } else if (section.title.toLowerCase().includes('conclusion')) {
                                sectionId = 'conclusion';
                            } else {
                                // Try to match with static sections
                                for (let i = 1; i <= 6; i++) {
                                    const staticSection = document.getElementById(`section${i}Editor`);
                                    if (staticSection && staticSection.value.includes(section.title)) {
                                        sectionId = `section${i}`;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        if (sectionId) {
                            applyFeedbackToSection(sectionId, feedback);
                            button.textContent = ' Applied';
                            button.style.background = '#10b981';
                            setTimeout(() => {
                                button.textContent = `Apply to ${section.title}`;
                                button.style.background = '#3b82f6';
                            }, 2000);
                        } else {
                            alert(`Could not find section "${section.title}" to apply feedback to.`);
                        }
                    };
                    
                    buttonContainer.appendChild(button);
                }
            });

            // Assemble modal
            modalContent.appendChild(closeButton);
            modalContent.appendChild(titleElement);
            modalContent.appendChild(contentElement);
            
            if (sections.length > 0) {
                applySection.appendChild(applyTitle);
                applySection.appendChild(applyDescription);
                applySection.appendChild(buttonContainer);
                modalContent.appendChild(applySection);
            }
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // Close modal functionality
            closeButton.onclick = () => document.body.removeChild(modal);
            modal.onclick = (e) => {
                if (e.target === modal) document.body.removeChild(modal);
            };
        }

        function explodeConfetti() {
            // Create confetti explosion
            const confettiCount = 150;
            const colors = ['#f39c12', '#e74c3c', '#3498db', '#2ecc71', '#9b59b6', '#f1c40f'];
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                
                // Random position across the top of the screen
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.top = '-10px';
                
                // Random size
                const size = Math.random() * 8 + 6;
                confetti.style.width = size + 'px';
                confetti.style.height = size + 'px';
                
                // Random color
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                
                // Random animation delay
                confetti.style.animationDelay = Math.random() * 3 + 's';
                
                // Random rotation
                confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                
                document.body.appendChild(confetti);
                
                // Remove confetti after animation
                setTimeout(() => {
                    if (confetti.parentNode) {
                        confetti.parentNode.removeChild(confetti);
                    }
                }, 3000);
            }
            
            // Add celebration message
            const celebration = document.createElement('div');
            celebration.innerHTML = '<strong>Article approved and saved successfully!</strong>';
            celebration.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
                color: white;
                padding: 20px 40px;
                border-radius: 15px;
                font-size: 1.5rem;
                font-weight: bold;
                z-index: 10000;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                animation: celebration-pulse 2s ease-in-out;
            `;
            
            // Add celebration animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes celebration-pulse {
                    0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
                    50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(celebration);
            
            // Remove celebration message after 3 seconds
            setTimeout(() => {
                if (celebration.parentNode) {
                    celebration.parentNode.removeChild(celebration);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 3000);
        }

        function exportToMarkdown() {
            // Update generatedContent with any edits made
            generatedContent.title = document.getElementById('titleEditor').value;
            generatedContent.introduction = document.getElementById('introductionEditor').value;
            generatedContent.section1 = document.getElementById('section1Editor').value;
            generatedContent.section2 = document.getElementById('section2Editor').value;
            generatedContent.section3 = document.getElementById('section3Editor').value;
            generatedContent.section4 = document.getElementById('section4Editor').value;
            generatedContent.section5 = document.getElementById('section5Editor').value;
            generatedContent.section6 = document.getElementById('section6Editor').value;
            generatedContent.conclusion = document.getElementById('conclusionEditor').value;

            // Assemble final content
            const finalContent = `# ${generatedContent.title}

${generatedContent.introduction}

${generatedContent.section1}

${generatedContent.section2}

${generatedContent.section3}

${generatedContent.section4}

${generatedContent.section5}

${generatedContent.section6}

${generatedContent.conclusion}`;

            // Create and download file
            const blob = new Blob([finalContent], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${workflowConfig.topic.replace(/\s+/g, '-').toLowerCase()}-article.md`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function exportToGoogleDocs() {
            // Update generatedContent with any edits made
            generatedContent.title = document.getElementById('titleEditor').value;
            generatedContent.introduction = document.getElementById('introductionEditor').value;
            generatedContent.section1 = document.getElementById('section1Editor').value;
            generatedContent.section2 = document.getElementById('section2Editor').value;
            generatedContent.section3 = document.getElementById('section3Editor').value;
            generatedContent.section4 = document.getElementById('section4Editor').value;
            generatedContent.section5 = document.getElementById('section5Editor').value;
            generatedContent.section6 = document.getElementById('section6Editor').value;
            generatedContent.conclusion = document.getElementById('conclusionEditor').value;

            // Handle dynamic sections for list-based articles
            const dynamicSections = document.querySelectorAll('[data-section]');
            let dynamicContent = '';
            dynamicSections.forEach(section => {
                const title = section.querySelector('h4')?.textContent || '';
                const content = section.querySelector('textarea')?.value || '';
                if (title && content) {
                    dynamicContent += `## ${title}\n\n${content}\n\n`;
                }
            });

            // Assemble final content
            const finalContent = `# ${generatedContent.title}

${generatedContent.introduction}

${generatedContent.section1}

${generatedContent.section2}

${generatedContent.section3}

${generatedContent.section4}

${generatedContent.section5}

${generatedContent.section6}

${dynamicContent}

${generatedContent.conclusion}`;

            // Create a new Google Doc using the proper URL format
            const googleDocsUrl = 'https://docs.google.com/document/create';
            
            // Open in new tab
            const newWindow = window.open(googleDocsUrl, '_blank');
            
            // Wait a moment for the page to load, then try to insert content
            setTimeout(() => {
                try {
                    // This will copy the content to clipboard for easy pasting
                    navigator.clipboard.writeText(finalContent).then(() => {
                        alert('Article content copied to clipboard! You can now paste it into the new Google Doc.');
                    }).catch(() => {
                        // Fallback: show the content in a prompt for manual copying
                        prompt('Copy this content to paste into Google Docs:', finalContent);
                    });
                } catch (error) {
                    prompt('Copy this content to paste into Google Docs:', finalContent);
                }
            }, 1000);

        }

        async function callOpenAI(apiKey, prompt, model = 'gpt-4') {
            // Check if this is a Deep Research model that uses v1/responses endpoint
            const isDeepResearch = model === 'o3-deep-research' || model === 'o4-mini-deep-research';
            
            if (isDeepResearch) {
                // Use v1/responses endpoint for Deep Research models
                const response = await fetch('https://api.openai.com/v1/responses', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: model,
                        input: prompt,
                        tools: [
                            {
                                type: "web_search_preview"
                            }
                        ]
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${errorData.error?.message || 'Unknown error'}`);
                }
                
                const data = await response.json();
                return data.choices?.[0]?.message?.content || data.text || data.content || 'No response generated';
            } else {
                // Use v1/chat/completions endpoint for standard models
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [
                            {
                                role: 'system',
                                content: 'You are a professional research assistant with access to web search capabilities. Conduct thorough, accurate research and provide verifiable sources. Focus on finding real, credible sources from established institutions and publications.'
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        max_tokens: 1500,
                        temperature: 0.7
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${errorData.error?.message || 'Unknown error'}`);
                }
                
                const data = await response.json();
                return data.choices?.[0]?.message?.content || 'No response generated';
            }
        }

        // Save/Load functionality
        function saveArticle(content) {
            const articleData = {
                id: Date.now().toString(),
                title: extractTitle(content),
                content: content,
                // Save individual sections for easy loading
                title: generatedContent.title || '',
                introduction: generatedContent.introduction || '',
                section1: generatedContent.section1 || '',
                section2: generatedContent.section2 || '',
                section3: generatedContent.section3 || '',
                section4: generatedContent.section4 || '',
                section5: generatedContent.section5 || '',
                section6: generatedContent.section6 || '',
                conclusion: generatedContent.conclusion || '',
                outline: generatedContent.outline || '',
                sections: generatedContent.sections || [],
                articleType: workflowConfig.articleType,
                topic: workflowConfig.topic,
                keywords: workflowConfig.keywords,
                primaryKeyword: workflowConfig.primaryKeyword,
                supportingKeywords: workflowConfig.supportingKeywords,
                clientName: workflowConfig.clientName,
                apiKey: workflowConfig.apiKey,
                toneBrand: workflowConfig.toneBrand,
                aiArtifacts: workflowConfig.aiArtifacts,
                // Enhanced metadata
                contentLength: content.length,
                wordCount: content.split(/\s+/).length,
                status: 'draft',
                version: 1,
                createdAt: new Date().toISOString(),
                lastModified: new Date().toISOString(),
                // Version history
                versionHistory: [{
                    version: 1,
                    timestamp: new Date().toISOString(),
                    content: content,
                    changes: 'Initial creation'
                }],
                // Permissions
                permissions: {
                    owner: 'current_user',
                    collaborators: [],
                    locked: false,
                    lockedBy: null
                }
            };

            // Get existing articles from localStorage
            const savedArticles = JSON.parse(localStorage.getItem('savedArticles') || '[]');
            
            // Add new article
            savedArticles.push(articleData);
            
            // Save back to localStorage
            localStorage.setItem('savedArticles', JSON.stringify(savedArticles));
            
            return articleData.id;
        }

        function loadArticle(articleId) {
            const savedArticles = JSON.parse(localStorage.getItem('savedArticles') || '[]');
            const article = savedArticles.find(a => a.id === articleId);
            
            if (article) {
                // Populate the form with article data
                document.getElementById('topic').value = article.topic || '';
                document.getElementById('primaryKeyword').value = article.primaryKeyword || '';
                
                // Populate supporting keywords
                const supportingKeywords = article.supportingKeywords || [];
                const supportingKeywordInputs = document.querySelectorAll('.supporting-keyword-input');
                supportingKeywordInputs.forEach((input, index) => {
                    input.value = supportingKeywords[index] || '';
                });
                updateSupportingKeywords();
                document.getElementById('articleType').value = article.articleType || 'general';
                // Set client select based on client name
                const clientSelect = document.getElementById('clientSelect');
                if (article.clientName) {
                    const clientId = Object.keys(CLIENT_DATA).find(id => CLIENT_DATA[id].name === article.clientName);
                    if (clientId) {
                        clientSelect.value = clientId;
                        loadClientData();
                    }
                }
                const apiKeyEl = document.getElementById('apiKey');
                if (apiKeyEl) apiKeyEl.value = article.apiKey || '';
                
                
                const aiArtifactsEl = document.getElementById('aiArtifactsText');
                if (aiArtifactsEl) aiArtifactsEl.value = article.aiArtifacts || '';
                
                
                // Update workflow config with all saved data
                workflowConfig.articleType = article.articleType;
                workflowConfig.topic = article.topic;
                workflowConfig.keywords = article.keywords;
                workflowConfig.primaryKeyword = article.primaryKeyword;
                workflowConfig.supportingKeywords = article.supportingKeywords;
                workflowConfig.clientName = article.clientName;
                workflowConfig.apiKey = article.apiKey;
                workflowConfig.toneBrand = article.toneBrand;
                workflowConfig.aiArtifacts = article.aiArtifacts;
                
                // Populate generatedContent with the loaded article data
                generatedContent = {
                    title: article.title || '',
                    introduction: article.introduction || '',
                    section1: article.section1 || '',
                    section2: article.section2 || '',
                    section3: article.section3 || '',
                    section4: article.section4 || '',
                    section5: article.section5 || '',
                    section6: article.section6 || '',
                    conclusion: article.conclusion || '',
                    outline: article.outline || '',
                    sections: article.sections || []
                };
                
                // Populate editors directly from saved data
                const titleEditor = document.getElementById('titleEditor');
                if (titleEditor) titleEditor.value = generatedContent.title;
                
                const introductionEditor = document.getElementById('introductionEditor');
                if (introductionEditor) introductionEditor.value = generatedContent.introduction;
                
                for (let i = 1; i <= 6; i++) {
                    const sectionEditor = document.getElementById(`section${i}Editor`);
                    if (sectionEditor) {
                        sectionEditor.value = generatedContent[`section${i}`] || '';
                    }
                }
                
                const conclusionEditor = document.getElementById('conclusionEditor');
                if (conclusionEditor) conclusionEditor.value = generatedContent.conclusion;
                
                // Update section visibility based on article type
                updateSectionVisibility(workflowConfig.articleType);
                
                // For list-based articles, create dynamic sections if we have section data
                if (workflowConfig.articleType === 'list-based' && article.sections && article.sections.length > 0) {
                    createDynamicSections(article.sections);
                }
                
                // Set current article ID
                currentArticleId = article.id;
                
                // Show final review section and display the article
                document.getElementById('finalReviewSection').classList.add('show');
                
                // Display the loaded article content
                displayLoadedArticle(article);
                
                return true;
            }
            return false;
        }


        function displayLoadedArticle(article) {
            
            // Hide the form and show the output section
            const formContainer = document.getElementById('formContainer');
            if (formContainer) {
                formContainer.style.display = 'none';
            }
            
            const outputSection = document.getElementById('outputSection');
            if (outputSection) {
                outputSection.classList.add('show');
            }
            
            // Build the final article content
            let finalContent = '';
            
            if (workflowConfig.articleType === 'list-based') {
                // For list-based articles, use the full article content or assemble from sections
                if (article.section1) {
                    finalContent = article.section1;
                } else if (article.sections && article.sections.length > 0) {
                    // Assemble from individual sections
                    for (let section of article.sections) {
                        if (section.title && section.content) {
                            finalContent += `## ${section.title}\n\n${section.content}\n\n`;
                        }
                    }
                } else if (article.content) {
                    finalContent = article.content;
                } else {
                    finalContent = 'No article content found.';
                }
            } else {
                // For general articles, assemble from sections
                if (article.title) finalContent += `# ${article.title}\n\n`;
                if (article.introduction) finalContent += `## Introduction\n\n${article.introduction}\n\n`;
                if (article.section1) finalContent += `## ${getSectionTitle(1)}\n\n${article.section1}\n\n`;
                if (article.section2) finalContent += `## ${getSectionTitle(2)}\n\n${article.section2}\n\n`;
                if (article.section3) finalContent += `## ${getSectionTitle(3)}\n\n${article.section3}\n\n`;
                if (article.section4) finalContent += `## ${getSectionTitle(4)}\n\n${article.section4}\n\n`;
                if (article.section5) finalContent += `## ${getSectionTitle(5)}\n\n${article.section5}\n\n`;
                if (article.section6) finalContent += `## ${getSectionTitle(6)}\n\n${article.section6}\n\n`;
                if (article.conclusion) finalContent += `## Conclusion\n\n${article.conclusion}\n\n`;
            }
            
            // Display the article in the output area
            const outputArea = document.getElementById('outputText');
            if (outputArea) {
                outputArea.textContent = finalContent;
                
                // Force the output section to be visible
                const outputSection = document.getElementById('outputSection');
                if (outputSection) {
                    outputSection.style.display = 'block';
                    outputSection.style.visibility = 'visible';
                    outputSection.classList.add('show');
                }
                
                // Also try to display in any other possible output areas
                const alternativeOutputs = [
                    'finalArticleOutput',
                    'articleOutput', 
                    'contentOutput',
                    'outputContent'
                ];
                
                alternativeOutputs.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.textContent = finalContent;
                    }
                });
                
            }

            // CRITICAL: Also populate the section editors for editing
            
            // Extract and populate title
            let title = '';
            const titleMatch = finalContent.match(/^#\s+(.+)$/m);
            if (titleMatch) {
                title = titleMatch[1];
            } else if (workflowConfig.articleType === 'list-based') {
                // For list-based articles, try to extract from first section
                const firstSectionMatch = finalContent.match(/^##\s+(\d+\.\s*.+?)(?:\s*-\s*(.+))?$/m);
                if (firstSectionMatch) {
                    const companyName = firstSectionMatch[1].replace(/^\d+\.\s*/, '').trim();
                    title = `Best ${companyName} Tools: A Comprehensive Guide`;
                } else {
                    title = 'Best Tools Guide';
                }
            }
            
            if (title) {
                const titleEditor = document.getElementById('titleEditor');
                if (titleEditor) {
                    titleEditor.value = title;
                }
            }

            // Extract and populate introduction
            const introMatch = finalContent.match(/##\s+Introduction\s*\n\n([\s\S]*?)(?=\n##|$)/);
            if (introMatch) {
                const introEditor = document.getElementById('introductionEditor');
                if (introEditor) {
                    introEditor.value = introMatch[1].trim();
                }
            }

            // Extract and populate conclusion
            const conclusionMatch = finalContent.match(/##\s+Conclusion\s*\n\n([\s\S]*?)$/);
            if (conclusionMatch) {
                const conclusionEditor = document.getElementById('conclusionEditor');
                if (conclusionEditor) {
                    conclusionEditor.value = conclusionMatch[1].trim();
                }
            }

            // For list-based articles, populate sections differently
            if (workflowConfig.articleType === 'list-based') {
                // Parse list-based content into sections
                const sections = parseListBasedContent(finalContent);
                
                // Clear existing section editors
                for (let i = 1; i <= 6; i++) {
                    const sectionEditor = document.getElementById(`section${i}Editor`);
                    if (sectionEditor) {
                        sectionEditor.value = '';
                    }
                }
                
                // Populate section editors with parsed content
                sections.forEach((section, index) => {
                    if (index < 6) { // Limit to 6 sections
                        const sectionEditor = document.getElementById(`section${index + 1}Editor`);
                        if (sectionEditor) {
                            sectionEditor.value = `## ${section.title}\n\n${section.content}`;
                        }
                    }
                });
            } else {
                // For general articles, extract sections using existing logic
                const sections = parseArticleIntoEditors(finalContent);
            }
            
            // Update section visibility based on article type
            updateSectionVisibility(workflowConfig.articleType);
            
            // For list-based articles, also create dynamic sections if needed
            if (workflowConfig.articleType === 'list-based' && article.sections && article.sections.length > 0) {
                createDynamicSections(article.sections);
            }
            
            // Add section editor listeners for real-time updates
            addSectionEditorListeners();
            
            // Ensure the right pane is updated with the assembled article
            setTimeout(() => {
                displayAssembledArticle();
                // Note: Don't force show output section - let user approve first
            }, 100);
        }

        function getSectionTitle(sectionNumber) {
            const titles = [
                '', // 0-indexed
                'Introduction',
                'First Section',
                'Second Section', 
                'Third Section',
                'Fourth Section',
                'Fifth Section',
                'Sixth Section',
                'Conclusion'
            ];
            return titles[sectionNumber] || `Section ${sectionNumber}`;
        }

        function showForm() {
            // Show the form and hide the output section
            const formContainer = document.querySelector('.form-container');
            const outputSection = document.getElementById('outputSection');
            
            if (formContainer) {
                formContainer.style.display = 'block';
            }
            
            if (outputSection) {
                outputSection.classList.remove('show');
                outputSection.style.display = 'none';
                outputSection.style.visibility = 'hidden';
            }
            
            // Scroll to the top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Debug function to test article loading
        function debugLoadArticle() {
            const savedArticles = JSON.parse(localStorage.getItem('savedArticles') || '[]');
            
            if (savedArticles.length > 0) {
                const article = savedArticles[0];
                displayLoadedArticle(article);
            } else {
            }
        }

        function extractTitle(content) {
            const titleMatch = content.match(/^#\s+(.+)$/m);
            return titleMatch ? titleMatch[1] : 'Untitled Article';
        }

        function parseArticleIntoEditors(content) {
            // Clear all editors first
            document.getElementById('titleEditor').value = '';
            document.getElementById('introductionEditor').value = '';
            for (let i = 1; i <= 6; i++) {
                document.getElementById(`section${i}Editor`).value = '';
            }
            document.getElementById('conclusionEditor').value = '';

            // Extract title
            const titleMatch = content.match(/^#\s+(.+)$/m);
            if (titleMatch) {
                const title = titleMatch[1];
                document.getElementById('titleEditor').value = title;
                // Store in generatedContent for consistency
                generatedContent.title = title;
            }

            // Split content by H2 headings
            const sections = content.split(/^##\s+/m).filter(section => section.trim());
            const parsedSections = [];
            
            for (let section of sections) {
                const lines = section.split('\n');
                const heading = lines[0].trim();
                const sectionContent = lines.slice(1).join('\n').trim();
                
                if (heading.toLowerCase().includes('introduction')) {
                    document.getElementById('introductionEditor').value = sectionContent;
                } else if (heading.toLowerCase().includes('conclusion')) {
                    document.getElementById('conclusionEditor').value = sectionContent;
                } else {
                    parsedSections.push({
                        title: heading,
                        content: sectionContent
                    });
                }
            }
            
            // Update section visibility based on article type
            updateSectionVisibility(workflowConfig.articleType);
            
            
            // Create dynamic sections for list-based articles
            if (workflowConfig.articleType === 'list-based' && parsedSections.length > 0) {
                createDynamicSections(parsedSections);
            } else {
                // For general articles, populate static sections
                for (let i = 0; i < parsedSections.length && i < 6; i++) {
                    const section = parsedSections[i];
                    document.getElementById(`section${i + 1}Editor`).value = `## ${section.title}\n\n${section.content}`;
                }
            }
        }

        function saveCurrentArticle() {
            // Assemble current content from editors
            let currentContent = '';
            
            const title = document.getElementById('titleEditor').value || 'Untitled Article';
            const introduction = document.getElementById('introductionEditor').value || '';
            const conclusion = document.getElementById('conclusionEditor').value || '';
            
            // Get dynamic sections if available
            const dynamicSections = getDynamicSectionContent();
            
            // Assemble the article
            currentContent = `# ${title}\n\n`;
            if (introduction) currentContent += `## Introduction\n\n${introduction}\n\n`;
            
            // Add dynamic sections (content already includes headings)
            dynamicSections.forEach(section => {
                currentContent += `${section.content}\n\n`;
            });
            
            // Add static sections for general articles
            if (workflowConfig.articleType === 'general') {
                for (let i = 1; i <= 6; i++) {
                    const section = document.getElementById(`section${i}Editor`).value;
                    if (section) {
                        currentContent += `${section}\n\n`;
                    }
                }
            }
            
            if (conclusion) currentContent += `## Conclusion\n\n${conclusion}\n\n`;
            
            if (currentContent.trim() === `# ${title}\n\n`) {
                alert('No content to save. Please add some content to the editors first.');
                return;
            }
            
            // Save the article
            const articleId = saveArticle(currentContent);
            alert(`Article saved successfully! ID: ${articleId}`);
        }

        function showSavedArticles() {
            const savedArticles = JSON.parse(localStorage.getItem('savedArticles') || '[]');
            
            if (savedArticles.length === 0) {
                alert('No saved articles found.');
                return;
            }

            // Create modal for article selection
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                padding: 20px;
                border-radius: 8px;
                max-width: 600px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            `;

            modalContent.innerHTML = `
                <h3>Saved Articles</h3>
                <div id="articleList"></div>
                <button onclick="this.closest('.modal').remove()" style="margin-top: 15px; padding: 8px 16px;">Close</button>
            `;

            modal.className = 'modal';
            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // Populate article list
            const articleList = modalContent.querySelector('#articleList');
            savedArticles.reverse().forEach(article => {
                const articleDiv = document.createElement('div');
                articleDiv.style.cssText = `
                    border: 1px solid #ddd;
                    padding: 15px;
                    margin: 10px 0;
                    border-radius: 4px;
                    cursor: pointer;
                `;
                articleDiv.innerHTML = `
                    <h4>${article.title}</h4>
                    <p><strong>Type:</strong> ${article.articleType}</p>
                    <p><strong>Topic:</strong> ${article.topic}</p>
                    <p><strong>Client:</strong> ${article.clientName || 'No client'}</p>
                    <p><strong>Created:</strong> ${new Date(article.createdAt).toLocaleDateString()}</p>
                    <p><strong>Last Modified:</strong> ${new Date(article.lastModified).toLocaleDateString()}</p>
                `;
                articleDiv.onclick = () => {
                    loadArticle(article.id);
                    modal.remove();
                };
                articleList.appendChild(articleDiv);
            });
        }

        function clearSavedArticles() {
            if (!confirm('Are you sure you want to clear all saved articles? This action cannot be undone.')) {
                return;
            }
            
            try {
                localStorage.removeItem('savedArticles');
                alert('All saved articles have been cleared successfully.');
            } catch (error) {
                console.error('Error clearing saved articles:', error);
                alert('Error clearing saved articles. Please try again.');
            }
        }

        function clearClientMemory() {
            if (!confirm('Are you sure you want to clear all client memory and preferences? This action cannot be undone.')) {
                return;
            }
            
            try {
                // Clear all client memory keys
                const keys = Object.keys(localStorage);
                keys.forEach(key => {
                    if (key.startsWith('clientMemory_')) {
                        localStorage.removeItem(key);
                    }
                });
                
                // Also clear any other memory-related keys
                localStorage.removeItem('clientPreferences');
                localStorage.removeItem('workflowConfig');
                
                alert('All client memory and preferences have been cleared successfully.');
            } catch (error) {
                console.error('Error clearing client memory:', error);
                alert('Error clearing client memory. Please try again.');
            }
        }

        function removeClientMemoryItem(clientName, category, itemIndex) {
            if (!clientName) return;
            
            const memory = getClientMemory(clientName);
            if (!memory) return;

            switch (category) {
                case 'commonEdits':
                    const section = Object.keys(memory.commonEdits)[itemIndex];
                    if (section && memory.commonEdits[section]) {
                        memory.commonEdits[section].splice(itemIndex, 1);
                        if (memory.commonEdits[section].length === 0) {
                            delete memory.commonEdits[section];
                        }
                    }
                    break;
                case 'feedbackPatterns':
                    memory.feedbackPatterns.splice(itemIndex, 1);
                    break;
                case 'tonePreferences':
                    memory.tonePreferences = '';
                    break;
                case 'aiArtifactsToAvoid':
                    memory.aiArtifactsToAvoid = '';
                    break;
            }

            memory.lastUpdated = new Date().toISOString();
            localStorage.setItem(`clientMemory_${clientName}`, JSON.stringify(memory));
        }

        function removeClientMemorySection(clientName, sectionName) {
            if (!clientName || !sectionName) return;
            
            const memory = getClientMemory(clientName);
            if (!memory) return;

            if (memory.commonEdits[sectionName]) {
                delete memory.commonEdits[sectionName];
                memory.lastUpdated = new Date().toISOString();
                localStorage.setItem(`clientMemory_${clientName}`, JSON.stringify(memory));
            }
        }

        function clearAllData() {
            if (!confirm('Are you sure you want to clear ALL stored data? This will remove:\n\n All saved articles\n All client memory and preferences\n All settings and configurations\n\nThis action cannot be undone.')) {
                return;
            }
            
            try {
                // Clear all localStorage data
                localStorage.clear();
                
                // Reset the form to default state
                document.getElementById('topicInput').value = '';
                document.getElementById('keywordInput').value = '';
                document.getElementById('additionalContextInput').value = '';
                document.getElementById('toneBrandInput').value = '';
                document.getElementById('articleTypeSelect').value = 'general';
                
                // Clear all editors
                document.getElementById('titleEditor').value = '';
                document.getElementById('introductionEditor').value = '';
                document.getElementById('conclusionEditor').value = '';
                
                // Clear static sections
                for (let i = 1; i <= 6; i++) {
                    const editor = document.getElementById(`section${i}Editor`);
                    if (editor) editor.value = '';
                }
                
                // Clear dynamic sections
                const dynamicSections = document.getElementById('dynamicSections');
                if (dynamicSections) {
                    dynamicSections.innerHTML = '';
                }
                
                // Reset workflow state
                currentStep = 1;
                generatedContent = {};
                workflowConfig = {
                    articleType: 'general',
                    apiKey: '',
                    toneBrand: '',
                    aiArtifacts: CODIFIED_AI_ARTIFACTS
                };
                
                // Reset global citations
                resetGlobalCitations();
                
                // Hide output section
                const outputSection = document.getElementById('outputSection');
                if (outputSection) {
                    outputSection.classList.remove('show');
                }
                
                // Reset progress indicators
                const progressDots = document.querySelectorAll('.progress-dot');
                progressDots.forEach(dot => {
                    dot.classList.remove('active', 'completed');
                });
                if (progressDots[0]) {
                    progressDots[0].classList.add('active');
                }
                
                alert('All data has been cleared successfully. The application has been reset to its default state.');
                
            } catch (error) {
                console.error('Error clearing all data:', error);
                alert('Error clearing data. Please try again.');
            }
        }



        // Article Deletion and Restore
        function deleteArticle(articleId, permanent = false) {
            const savedArticles = JSON.parse(localStorage.getItem('savedArticles') || '[]');
            const trashArticles = JSON.parse(localStorage.getItem('trashArticles') || '[]');
            const articleIndex = savedArticles.findIndex(a => a.id === articleId);
            
            if (articleIndex === -1) return;
            
            const article = savedArticles[articleIndex];
            
            if (permanent) {
                // Permanently delete from trash
                const trashIndex = trashArticles.findIndex(a => a.id === articleId);
                if (trashIndex !== -1) {
                    trashArticles.splice(trashIndex, 1);
                    localStorage.setItem('trashArticles', JSON.stringify(trashArticles));
                }
                alert('Article permanently deleted.');
            } else {
                // Move to trash
                article.deletedAt = new Date().toISOString();
                article.status = 'deleted';
                trashArticles.push(article);
                savedArticles.splice(articleIndex, 1);
                
                localStorage.setItem('savedArticles', JSON.stringify(savedArticles));
                localStorage.setItem('trashArticles', JSON.stringify(trashArticles));
                alert('Article moved to trash.');
            }
        }

        function restoreArticle(articleId) {
            const savedArticles = JSON.parse(localStorage.getItem('savedArticles') || '[]');
            const trashArticles = JSON.parse(localStorage.getItem('trashArticles') || '[]');
            const articleIndex = trashArticles.findIndex(a => a.id === articleId);
            
            if (articleIndex === -1) return;
            
            const article = trashArticles[articleIndex];
            article.status = 'draft';
            delete article.deletedAt;
            
            savedArticles.push(article);
            trashArticles.splice(articleIndex, 1);
            
            localStorage.setItem('savedArticles', JSON.stringify(savedArticles));
            localStorage.setItem('trashArticles', JSON.stringify(trashArticles));
            alert('Article restored from trash.');
        }

        function showTrash() {
            const trashArticles = JSON.parse(localStorage.getItem('trashArticles') || '[]');
            
            if (trashArticles.length === 0) {
                alert('Trash is empty.');
                return;
            }

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>Trash (${trashArticles.length} articles)</h3>
                        <span class="close" onclick="this.parentElement.parentElement.parentElement.remove()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="trash-list">
                            ${trashArticles.map(article => `
                                <div class="trash-item">
                                    <div class="article-info">
                                        <h4>${article.title}</h4>
                                        <p>Client: ${article.clientName} | Deleted: ${new Date(article.deletedAt).toLocaleString()}</p>
                                    </div>
                                    <div class="trash-actions">
                                        <button onclick="restoreArticle('${article.id}'); this.parentElement.parentElement.parentElement.remove();" class="btn btn-small">Restore</button>
                                        <button onclick="deleteArticle('${article.id}', true); this.parentElement.parentElement.parentElement.remove();" class="btn btn-small btn-danger">Delete Permanently</button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Enhanced Article Search
        function searchArticles(query, filters = {}) {
            const savedArticles = JSON.parse(localStorage.getItem('savedArticles') || '[]');
            let results = savedArticles;
            
            // Filter by query
            if (query) {
                results = results.filter(article => 
                    article.title.toLowerCase().includes(query.toLowerCase()) ||
                    article.content.toLowerCase().includes(query.toLowerCase()) ||
                    (article.keywords && article.keywords.toLowerCase().includes(query.toLowerCase())) ||
                    (article.primaryKeyword && article.primaryKeyword.toLowerCase().includes(query.toLowerCase())) ||
                    (article.supportingKeywords && article.supportingKeywords.some(k => k.toLowerCase().includes(query.toLowerCase()))) ||
                    article.clientName.toLowerCase().includes(query.toLowerCase())
                );
            }
            
            // Apply filters
            if (filters.client) {
                results = results.filter(article => article.clientName === filters.client);
            }
            
            if (filters.articleType) {
                results = results.filter(article => article.articleType === filters.articleType);
            }
            
            if (filters.status) {
                results = results.filter(article => article.status === filters.status);
            }
            
            
            return results;
        }

        function showArticleSearch() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>Search Articles</h3>
                        <span class="close" onclick="this.parentElement.parentElement.parentElement.remove()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="search-form">
                            <input type="text" id="searchQuery" placeholder="Search by title, content, primary keyword, supporting keywords, or client..." style="width: 100%; margin-bottom: 15px; padding: 10px;">
                            <div class="filter-row">
                                <select id="clientFilter">
                                    <option value="">All Clients</option>
                                </select>
                                <select id="typeFilter">
                                    <option value="">All Types</option>
                                    <option value="general">General</option>
                                    <option value="list-based">List-based</option>
                                </select>
                                <select id="statusFilter">
                                    <option value="">All Statuses</option>
                                    <option value="draft">Draft</option>
                                    <option value="published">Published</option>
                                    <option value="archived">Archived</option>
                                </select>
                            </div>
                            <button onclick="performSearch()" class="btn">Search</button>
                        </div>
                        <div id="searchResults" class="search-results"></div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Populate client filter
            const savedArticles = JSON.parse(localStorage.getItem('savedArticles') || '[]');
            const clients = [...new Set(savedArticles.map(a => a.clientName))];
            const clientFilter = document.getElementById('clientFilter');
            clients.forEach(client => {
                const option = document.createElement('option');
                option.value = client;
                option.textContent = client;
                clientFilter.appendChild(option);
            });
        }

        function performSearch() {
            const query = document.getElementById('searchQuery').value;
            const filters = {
                client: document.getElementById('clientFilter').value,
                articleType: document.getElementById('typeFilter').value,
                status: document.getElementById('statusFilter').value,
            };
            
            const results = searchArticles(query, filters);
            const resultsContainer = document.getElementById('searchResults');
            
            if (results.length === 0) {
                resultsContainer.innerHTML = '<p>No articles found matching your criteria.</p>';
                return;
            }
            
            resultsContainer.innerHTML = results.map(article => `
                <div class="search-result-item">
                    <h4>${article.title}</h4>
                    <p><strong>Client:</strong> ${article.clientName} | <strong>Type:</strong> ${article.articleType} | <strong>Status:</strong> ${article.status}</p>
                    <p><strong>Created:</strong> ${new Date(article.createdAt).toLocaleString()} | <strong>Modified:</strong> ${new Date(article.lastModified).toLocaleString()}</p>
                    <div class="result-actions">
                        <button onclick="loadArticle('${article.id}'); this.closest('.modal').remove();" class="btn btn-small">Load</button>
                        <button onclick="deleteArticle('${article.id}')" class="btn btn-small btn-danger">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        // Section visibility management
        function updateSectionVisibility(articleType) {
            const staticSections = document.getElementById('staticSections');
            const dynamicSections = document.getElementById('dynamicSections');
            
            if (articleType === 'list-based') {
                // Hide static sections for list-based articles
                staticSections.classList.add('hidden');
                // Dynamic sections will be shown when created
            } else {
                // Show static sections for general articles
                staticSections.classList.remove('hidden');
                // Clear dynamic sections
                dynamicSections.innerHTML = '';
            }
        }

        // Dynamic section management
        function createDynamicSections(sections) {
            const container = document.getElementById('dynamicSections');
            container.innerHTML = '';

            // Filter out introduction and conclusion sections
            const contentSections = sections.filter(section => 
                !section.title.toLowerCase().includes('introduction') && 
                !section.title.toLowerCase().includes('conclusion')
            );

            contentSections.forEach((section, index) => {
                const sectionNumber = index + 1;
                const sectionId = `dynamicSection${sectionNumber}`;
                
                // Clean the content to remove redundant headings
                let cleanContent = section.content;
                
                // Remove H1 headings that match the section title
                const h1Pattern = new RegExp(`^#\\s*${section.title.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*$`, 'gm');
                cleanContent = cleanContent.replace(h1Pattern, '');
                
                // Remove H2 headings that match the section title
                const h2Pattern = new RegExp(`^##\\s*${section.title.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*$`, 'gm');
                cleanContent = cleanContent.replace(h2Pattern, '');
                
                // Clean up extra whitespace
                cleanContent = cleanContent.trim();
                
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'section-editor';
                sectionDiv.setAttribute('data-section', sectionId);
                
                sectionDiv.innerHTML = `
                    <div class="section-header">
                        <h4>${section.title}</h4>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="text" id="${sectionId}Feedback" placeholder="What should be revised?" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 0.8rem; width: 200px;">
                            <button type="button" class="btn-small" onclick="regenerateSection('${sectionId}')">Regenerate</button>
                        </div>
                    </div>
                    <textarea class="section-textarea" id="${sectionId}Editor" placeholder="${section.title} content will appear here...">${cleanContent}</textarea>
                `;
                
                container.appendChild(sectionDiv);
            });
            
        }

        function getDynamicSectionContent() {
            const container = document.getElementById('dynamicSections');
            const sections = [];
            
            Array.from(container.children).forEach(sectionDiv => {
                const sectionId = sectionDiv.getAttribute('data-section');
                const editor = document.getElementById(sectionId + 'Editor');
                const title = sectionDiv.querySelector('h4').textContent;
                
                if (editor && editor.value.trim()) {
                    // Add the heading back to the content
                    const contentWithHeading = `## ${title}\n\n${editor.value}`;
                    sections.push({
                        title: title,
                        content: contentWithHeading,
                        id: sectionId
                    });
                }
            });
            
            return sections;
        }

        // Client memory system
        function getClientMemory(clientName) {
            if (!clientName) return null;
            return JSON.parse(localStorage.getItem(`clientMemory_${clientName}`) || 'null');
        }

        function updateClientMemory(clientName, action, data) {
            if (!clientName) return;
            
            let memory = getClientMemory(clientName) || {
                clientName: clientName,
                preferences: {},
                commonEdits: {},
                feedbackPatterns: [],
                tonePreferences: '',
                aiArtifactsToAvoid: '',
                createdAt: new Date().toISOString(),
                lastUpdated: new Date().toISOString()
            };

            memory.lastUpdated = new Date().toISOString();

            switch (action) {
                case 'tone_preference':
                    memory.tonePreferences = data;
                    break;
                case 'ai_artifacts':
                    memory.aiArtifactsToAvoid = data;
                    break;
                case 'common_edit':
                    const editKey = data.section;
                    if (!memory.commonEdits[editKey]) {
                        memory.commonEdits[editKey] = [];
                    }
                    memory.commonEdits[editKey].push({
                        feedback: data.feedback,
                        timestamp: new Date().toISOString()
                    });
                    break;
                case 'feedback_pattern':
                    memory.feedbackPatterns.push({
                        pattern: data,
                        timestamp: new Date().toISOString()
                    });
                    break;
            }

            localStorage.setItem(`clientMemory_${clientName}`, JSON.stringify(memory));
        }

        function getClientContext(clientName) {
            const memory = getClientMemory(clientName);
            if (!memory) return '';

            let context = `\n\nCLIENT CONTEXT (${clientName}):\n`;
            
            if (memory.tonePreferences) {
                context += `Tone Preferences: ${memory.tonePreferences}\n`;
            }
            
            if (memory.aiArtifactsToAvoid) {
                context += `AI Artifacts to Avoid: ${memory.aiArtifactsToAvoid}\n`;
            }
            
            if (Object.keys(memory.commonEdits).length > 0) {
                context += `Common Edit Patterns:\n`;
                Object.entries(memory.commonEdits).forEach(([section, edits]) => {
                    const recentEdits = edits.slice(-3); // Last 3 edits
                    context += `- ${section}: ${recentEdits.map(e => e.feedback).join(', ')}\n`;
                });
            }
            
            if (memory.feedbackPatterns.length > 0) {
                const recentPatterns = memory.feedbackPatterns.slice(-5); // Last 5 patterns
                context += `Recent Feedback Patterns: ${recentPatterns.map(p => p.pattern).join(', ')}\n`;
            }
            
            return context;
        }

        // Helper function to collect all sections for review
        function collectAllSections() {
            const sections = [];
            
            // Add title
            const title = document.getElementById('titleEditor').value.trim();
            if (title) {
                sections.push({ title: 'Title', content: title });
            }
            
            // Add introduction
            const introduction = document.getElementById('introductionEditor').value.trim();
            if (introduction) {
                sections.push({ title: 'Introduction', content: introduction });
            }
            
            // Add dynamic sections (for list-based articles)
            const dynamicSections = getDynamicSectionContent();
            dynamicSections.forEach(section => {
                sections.push({ title: section.title, content: section.content });
            });
            
            // Add static sections (for general articles)
            if (workflowConfig.articleType === 'general') {
                for (let i = 1; i <= 6; i++) {
                    const section = document.getElementById(`section${i}Editor`).value.trim();
                    if (section) {
                        sections.push({ title: `Section ${i}`, content: section });
                    }
                }
            }
            
            // Add conclusion
            const conclusion = document.getElementById('conclusionEditor').value.trim();
            if (conclusion) {
                sections.push({ title: 'Conclusion', content: conclusion });
            }
            
            return sections;
        }

        // Memory debugging and testing functions

        function showClientMemory() {
            const clientSelect = document.getElementById('clientSelect');
            const clientId = clientSelect ? clientSelect.value : '';
            
            if (!clientId) {
                alert('Please select a client first to view their memory.');
                return;
            }

            const clientData = CLIENT_DATA[clientId];
            if (!clientData) {
                alert('Client data not found.');
                return;
            }

            const memory = getClientMemory(clientData.name);
            
            if (!memory) {
                alert(`No memory found for client: ${clientData.name}`);
                return;
            }

            // Create modal to display memory data with individual item management
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                padding: 20px;
                border-radius: 8px;
                max-width: 900px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            `;

            // Build memory display with individual item management
            let memoryHTML = `
                <h3>Client Memory: ${clientData.name}</h3>
                <div style="margin-bottom: 20px; font-size: 12px; color: #666;">
                    Created: ${new Date(memory.createdAt).toLocaleString()}<br>
                    Last Updated: ${new Date(memory.lastUpdated).toLocaleString()}
                </div>
            `;

            // Tone Preferences
            if (memory.tonePreferences) {
                memoryHTML += `
                    <div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                        <h4 style="margin: 0 0 8px 0; color: #333;">Tone Preferences</h4>
                        <p style="margin: 0 0 8px 0; font-size: 14px;">${memory.tonePreferences}</p>
                        <button onclick="removeClientMemoryItem('${clientData.name}', 'tonePreferences', 0); this.closest('.modal').remove(); showClientMemory();" 
                                style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; font-size: 12px; cursor: pointer;">
                            Remove
                        </button>
                    </div>
                `;
            }

            // AI Artifacts to Avoid
            if (memory.aiArtifactsToAvoid) {
                memoryHTML += `
                    <div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                        <h4 style="margin: 0 0 8px 0; color: #333;">AI Artifacts to Avoid</h4>
                        <p style="margin: 0 0 8px 0; font-size: 14px;">${memory.aiArtifactsToAvoid}</p>
                        <button onclick="removeClientMemoryItem('${clientData.name}', 'aiArtifactsToAvoid', 0); this.closest('.modal').remove(); showClientMemory();" 
                                style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; font-size: 12px; cursor: pointer;">
                            Remove
                        </button>
                    </div>
                `;
            }

            // Common Edits
            if (Object.keys(memory.commonEdits).length > 0) {
                memoryHTML += `
                    <div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                        <h4 style="margin: 0 0 8px 0; color: #333;">Common Edit Patterns</h4>
                `;
                
                Object.entries(memory.commonEdits).forEach(([section, edits]) => {
                    memoryHTML += `
                        <div style="margin-bottom: 10px; padding: 8px; background: #f8f9fa; border-radius: 3px;">
                            <strong>${section}:</strong>
                            <button onclick="removeClientMemorySection('${clientData.name}', '${section}'); this.closest('.modal').remove(); showClientMemory();" 
                                    style="background: #dc3545; color: white; border: none; padding: 2px 6px; border-radius: 3px; font-size: 11px; cursor: pointer; margin-left: 10px;">
                                Remove Section
                            </button>
                            <ul style="margin: 5px 0 0 0; padding-left: 20px;">
                    `;
                    
                    edits.forEach((edit, index) => {
                        memoryHTML += `
                            <li style="margin-bottom: 5px; font-size: 13px;">
                                "${edit.feedback}" 
                                <span style="color: #666; font-size: 11px;">(${new Date(edit.timestamp).toLocaleString()})</span>
                                <button onclick="removeClientMemoryItem('${clientData.name}', 'commonEdits', ${index}); this.closest('.modal').remove(); showClientMemory();" 
                                        style="background: #dc3545; color: white; border: none; padding: 1px 4px; border-radius: 2px; font-size: 10px; cursor: pointer; margin-left: 5px;">
                                    
                                </button>
                            </li>
                        `;
                    });
                    
                    memoryHTML += `</ul></div>`;
                });
                
                memoryHTML += `</div>`;
            }

            // Feedback Patterns
            if (memory.feedbackPatterns && memory.feedbackPatterns.length > 0) {
                memoryHTML += `
                    <div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                        <h4 style="margin: 0 0 8px 0; color: #333;">Feedback Patterns</h4>
                        <ul style="margin: 0; padding-left: 20px;">
                `;
                
                memory.feedbackPatterns.forEach((pattern, index) => {
                    memoryHTML += `
                        <li style="margin-bottom: 5px; font-size: 13px;">
                            "${pattern.pattern}" 
                            <span style="color: #666; font-size: 11px;">(${new Date(pattern.timestamp).toLocaleString()})</span>
                            <button onclick="removeClientMemoryItem('${clientData.name}', 'feedbackPatterns', ${index}); this.closest('.modal').remove(); showClientMemory();" 
                                    style="background: #dc3545; color: white; border: none; padding: 1px 4px; border-radius: 2px; font-size: 10px; cursor: pointer; margin-left: 5px;">
                                
                            </button>
                        </li>
                    `;
                });
                
                memoryHTML += `</ul></div>`;
            }

            // No memory message
            if (!memory.tonePreferences && !memory.aiArtifactsToAvoid && Object.keys(memory.commonEdits).length === 0 && (!memory.feedbackPatterns || memory.feedbackPatterns.length === 0)) {
                memoryHTML += `
                    <div style="text-align: center; padding: 20px; color: #666;">
                        No memory items found for this client.
                    </div>
                `;
            }

            memoryHTML += `
                <div style="margin-top: 20px; text-align: center;">
                    <button onclick="clearClientMemory(); this.closest('.modal').remove();" 
                            style="background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 4px; margin-right: 10px; cursor: pointer;">
                        Clear All Memory
                    </button>
                    <button onclick="this.closest('.modal').remove()" 
                            style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
                        Close
                    </button>
                </div>
            `;

            modalContent.innerHTML = memoryHTML;

            modal.className = 'modal';
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        }









        // Add event listener for article type changes
        document.addEventListener('DOMContentLoaded', function() {
            const articleTypeSelect = document.getElementById('articleType');
            if (articleTypeSelect) {
                articleTypeSelect.addEventListener('change', function() {
                    updateSectionVisibility(this.value);
                });
            }
            
            // Add section editor listeners for real-time right pane updates
            addSectionEditorListeners();
            
            // Verify settings modal exists
            const settingsModal = document.getElementById('settingsModal');
            if (!settingsModal) {
                console.error('Settings modal not found in DOM');
            }
            
            // Load API key from localStorage if available
            const savedApiKey = localStorage.getItem('openaiApiKey');
            if (savedApiKey) {
                workflowConfig.apiKey = savedApiKey;
            }
            
            // Load client data from localStorage
            loadClientDataFromStorage();
            
            // Populate client dropdown with all clients
            populateClientDropdown();
        });

        // Screenshot Modal Functions
        function showScreenshotModal() {
            // Create modal overlay
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            
            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.className = 'modal-content';
            modalContent.style.maxWidth = '800px';
            modalContent.style.width = '90%';
            
            modalContent.innerHTML = `
                <div class="modal-header">
                    <h3> Screenshot Capture</h3>
                    <span class="close" onclick="closeScreenshotModal()">&times;</span>
                </div>
                <div class="modal-body">
                    <div class="screenshot-modal-content">
                        <div class="screenshot-input-section">
                            <label for="screenshotUrl" class="screenshot-label">URL to Screenshot</label>
                            <input type="url" id="screenshotUrl" placeholder="https://example.com" class="screenshot-input-field">
                            
                            <div class="screenshot-options">
                                <select id="imageFormat" class="screenshot-select">
                                    <option value="png">PNG</option>
                                    <option value="jpeg">JPG</option>
                                </select>
                                <input type="number" id="imageQuality" placeholder="90" min="1" max="100" value="90" class="screenshot-quality" title="Image quality (1-100)">
                            </div>
                            
                            <div class="screenshot-buttons">
                                <button type="button" class="btn btn-primary" onclick="captureUrlScreenshot('visible')" title="Capture visible area">
                                    <span class="btn-icon"></span>
                                    Visible
                                </button>
                                <button type="button" class="btn btn-primary" onclick="captureUrlScreenshot('fullpage')" title="Capture full page">
                                    <span class="btn-icon"></span>
                                    Full Page
                                </button>
                            </div>
                        </div>
                        
                        <div class="screenshot-stats">
                            <div class="stat-card">
                                <div class="stat-number" id="totalScreenshots">0</div>
                                <div class="stat-label">Screenshots</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number" id="totalSize">0 KB</div>
                                <div class="stat-label">Total Size</div>
                            </div>
                        </div>
                        
                        <div class="screenshot-list" id="screenshotList">
                            <div class="empty-state">
                                <div class="empty-icon"></div>
                                <p>No screenshots yet</p>
                            </div>
                        </div>
                        
                        <div class="screenshot-actions">
                            <button type="button" class="btn btn-secondary" onclick="downloadAllImages()" title="Download all screenshots">
                                <span class="btn-icon"></span>
                                Download All
                            </button>
                            <button type="button" class="btn btn-secondary" onclick="downloadAllAsZip()" title="Download as ZIP">
                                <span class="btn-icon"></span>
                                Download ZIP
                            </button>
                            <button type="button" class="btn btn-danger" onclick="clearScreenshots()" title="Clear all screenshots">
                                <span class="btn-icon"></span>
                                Clear All
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Close modal when clicking outside
            modal.onclick = function(e) {
                if (e.target === modal) {
                    closeScreenshotModal();
                }
            };
        }

        function closeScreenshotModal() {
            const modal = document.querySelector('.modal');
            if (modal) {
                modal.remove();
            }
        }

        // Navigation Functions
        function showContentGeneration(event) {
            // Update active nav item
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            event.target.closest('.nav-item').classList.add('active');
            
            // Show content generation area (this is already visible by default)
            document.querySelector('.main-content').style.display = 'block';
            
            // Update main title
            document.querySelector('.main-title').textContent = 'Content Generation';
        }

        function showArticleManagement(event) {
            // Update active nav item
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            event.target.closest('.nav-item').classList.add('active');
            
            // Show article management interface
            showSavedArticles();
            
            // Update main title
            document.querySelector('.main-title').textContent = 'Article Management';
        }




        // Client Management Functions
        function loadClientData() {
            const clientSelect = document.getElementById('clientSelect');
            const clientId = clientSelect.value;
            const clientInfo = document.getElementById('clientInfo');
            const clientInfoTitle = document.getElementById('clientInfoTitle');
            const clientToneInfo = document.getElementById('clientToneInfo');
            const clientArtifactsInfo = document.getElementById('clientArtifactsInfo');
            const clientLastUpdated = document.getElementById('clientLastUpdated');

            if (!clientId) {
                clientInfo.classList.remove('show');
                return;
            }

            const client = CLIENT_DATA[clientId];
            if (!client) {
                clientInfo.classList.remove('show');
                return;
            }

            // Update client info display
            updateClientInfoDisplay(client);

            // Update workflow config
            workflowConfig.clientName = client.name;
            workflowConfig.clientId = clientId;
            workflowConfig.toneBrand = client.tone;
            workflowConfig.aiArtifacts = client.aiArtifacts;

            
            // Clear any displayed article when switching clients
            clearDisplayedArticle();
        }

        function showClientManagement() {
            // Create modal overlay
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            
            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.className = 'modal-content';
            modalContent.style.maxWidth = '1000px';
            modalContent.style.width = '90%';
            
            modalContent.innerHTML = `
                <div class="modal-header">
                    <h3> Client Management</h3>
                    <span class="close" onclick="closeClientManagement()">&times;</span>
                </div>
                <div class="modal-body">
                    <div class="client-management-content">
                        <div class="client-list">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                                <h4>All Clients</h4>
                                <button class="btn btn-primary" onclick="createNewClient()">
                                    <span class="btn-icon"></span>
                                    Create New Client
                                </button>
                            </div>
                            <div class="client-grid" id="clientGrid">
                                ${Object.entries(CLIENT_DATA).map(([id, client]) => `
                                    <div class="client-card" onclick="editClient('${id}')">
                                        <div class="client-card-header">
                                            <h5>${client.displayName}</h5>
                                            <button class="btn btn-small btn-secondary" onclick="event.stopPropagation(); editClient('${id}')">Edit</button>
                                        </div>
                                        <div class="client-card-content">
                                            <p><strong>Tone:</strong> ${client.tone.substring(0, 100)}${client.tone.length > 100 ? '...' : ''}</p>
                                            <p><strong>Last Updated:</strong> ${new Date(client.lastUpdated).toLocaleDateString()}</p>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Close modal when clicking outside
            modal.onclick = function(e) {
                if (e.target === modal) {
                    closeClientManagement();
                }
            };
        }

        function closeClientManagement() {
            const modal = document.querySelector('.modal');
            if (modal) {
                modal.remove();
            }
        }

        function showSettings() {
            const modal = document.getElementById('settingsModal');
            if (modal) {
                modal.classList.add('show');
            } else {
                console.error('Settings modal not found');
            }
        }

        function closeSettings() {
            const modal = document.getElementById('settingsModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }

        function saveSettings() {
            const apiKey = document.getElementById('settingsApiKey').value.trim();
            if (!apiKey) {
                alert('Please enter your OpenAI API key');
                return;
            }
            
            // Store the API key globally
            if (typeof workflowConfig === 'undefined') {
                workflowConfig = {};
            }
            workflowConfig.apiKey = apiKey;
            
            // Also store in localStorage for persistence
            localStorage.setItem('openaiApiKey', apiKey);
            
            alert('Settings saved successfully!');
            closeSettings();
        }

        function editClient(clientId) {
            const client = CLIENT_DATA[clientId];
            if (!client) return;

            // Create edit modal
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            
            const modalContent = document.createElement('div');
            modalContent.className = 'modal-content';
            modalContent.style.maxWidth = '600px';
            
            modalContent.innerHTML = `
                <div class="modal-header">
                    <h3>Edit ${client.displayName}</h3>
                    <span class="close" onclick="closeEditClient()">&times;</span>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="editClientName">Client Name</label>
                        <input type="text" id="editClientName" value="${client.name}" readonly>
                    </div>
                    <div class="form-group">
                        <label for="editClientTone">Tone & Voice Guidelines</label>
                        <textarea id="editClientTone" rows="4" placeholder="Enter tone and voice guidelines...">${client.tone}</textarea>
                    </div>
                    <div class="form-group">
                        <label for="editClientArtifacts">AI Artifacts to Avoid</label>
                        <textarea id="editClientArtifacts" rows="3" placeholder="Enter specific AI artifacts to avoid...">${client.aiArtifacts}</textarea>
                    </div>
                    <div class="form-actions">
                        <button class="btn btn-primary" onclick="saveClient('${clientId}')">Save Changes</button>
                        <button class="btn btn-secondary" onclick="closeEditClient()">Cancel</button>
                    </div>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            modal.onclick = function(e) {
                if (e.target === modal) {
                    closeEditClient();
                }
            };
        }

        function closeEditClient() {
            const modal = document.querySelector('.modal');
            if (modal) {
                modal.remove();
            }
        }

        function saveClient(clientId) {
            const client = CLIENT_DATA[clientId];
            if (!client) return;

            const newTone = document.getElementById('editClientTone').value.trim();
            const newArtifacts = document.getElementById('editClientArtifacts').value.trim();

            // Update client data
            client.tone = newTone || client.tone;
            client.aiArtifacts = newArtifacts || client.aiArtifacts;
            client.lastUpdated = new Date().toISOString();

            // Save to localStorage
            localStorage.setItem('clientData', JSON.stringify(CLIENT_DATA));

            // Close edit modal
            closeEditClient();

            // Refresh client management modal
            closeClientManagement();
            showClientManagement();

            // Refresh client dropdown to reflect any changes
            populateClientDropdown();

            // Update current client info if this is the selected client
            const currentClientId = document.getElementById('clientSelect').value;
            if (currentClientId === clientId) {
                loadClientData();
            }

            alert('Client information updated successfully!');
        }

        function createNewClient() {
            // Create new client modal
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            
            const modalContent = document.createElement('div');
            modalContent.className = 'modal-content';
            modalContent.style.maxWidth = '600px';
            
            modalContent.innerHTML = `
                <div class="modal-header">
                    <h3>Create New Client</h3>
                    <span class="close" onclick="closeCreateClient()">&times;</span>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="newClientName">Client Name *</label>
                        <input type="text" id="newClientName" placeholder="e.g., Acme Corp" required>
                    </div>
                    <div class="form-group">
                        <label for="newClientDisplayName">Display Name</label>
                        <input type="text" id="newClientDisplayName" placeholder="e.g., Acme Corporation (optional)">
                        <small style="color: #6b7280; font-size: 0.8rem;">If left empty, will use Client Name</small>
                    </div>
                    <div class="form-group">
                        <label for="newClientTone">Tone & Voice Guidelines</label>
                        <textarea id="newClientTone" rows="4" placeholder="Enter tone and voice guidelines for this client..."></textarea>
                    </div>
                    <div class="form-group">
                        <label for="newClientArtifacts">AI Artifacts to Avoid</label>
                        <textarea id="newClientArtifacts" rows="3" placeholder="Enter specific AI artifacts to avoid for this client..."></textarea>
                    </div>
                    <div class="form-actions">
                        <button class="btn btn-primary" onclick="saveNewClient()">Create Client</button>
                        <button class="btn btn-secondary" onclick="closeCreateClient()">Cancel</button>
                    </div>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            modal.onclick = function(e) {
                if (e.target === modal) {
                    closeCreateClient();
                }
            };
        }

        function closeCreateClient() {
            const modal = document.querySelector('.modal');
            if (modal) {
                modal.remove();
            }
        }

        function saveNewClient() {
            const clientName = document.getElementById('newClientName').value.trim();
            const displayName = document.getElementById('newClientDisplayName').value.trim();
            const tone = document.getElementById('newClientTone').value.trim();
            const artifacts = document.getElementById('newClientArtifacts').value.trim();

            if (!clientName) {
                alert('Please enter a client name');
                return;
            }

            // Generate client ID from name (lowercase, replace spaces with hyphens)
            const clientId = clientName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');

            // Check if client already exists
            if (CLIENT_DATA[clientId]) {
                alert('A client with this name already exists. Please choose a different name.');
                return;
            }

            // Create new client
            CLIENT_DATA[clientId] = {
                name: clientName,
                displayName: displayName || clientName,
                tone: tone || 'No tone guidelines set',
                aiArtifacts: artifacts || 'Use default AI artifacts list',
                lastUpdated: new Date().toISOString()
            };

            // Save to localStorage
            localStorage.setItem('clientData', JSON.stringify(CLIENT_DATA));

            // Close create modal
            closeCreateClient();

            // Refresh client management modal
            closeClientManagement();
            showClientManagement();

            // Refresh client dropdown to include new client
            populateClientDropdown();

            alert('Client created successfully!');
        }


        // Edit client tone & voice directly from client info
        function editClientTone(clientId) {
            // Find the client in the dropdown and select it
            const clientSelect = document.getElementById('clientSelect');
            if (clientSelect) {
                clientSelect.value = clientId;
                loadClientData();
            }
            
            // Open the client management modal to edit
            showClientManagement();
            
            // Find and click the edit button for this client
            setTimeout(() => {
                const editButton = document.querySelector(`[onclick*="editClient('${clientId}')"]`);
                if (editButton) {
                    editButton.click();
                }
            }, 100);
        }

        // Update client info display without overwriting textarea
        function updateClientInfoDisplay(client) {
            const clientInfo = document.getElementById('clientInfo');
            const clientInfoTitle = document.getElementById('clientInfoTitle');
            const clientToneInfo = document.getElementById('clientToneInfo');
            const clientArtifactsInfo = document.getElementById('clientArtifactsInfo');
            const clientLastUpdated = document.getElementById('clientLastUpdated');

            if (clientInfo && clientInfoTitle && clientToneInfo && clientArtifactsInfo && clientLastUpdated) {
                clientInfoTitle.textContent = `${client.displayName} - Client Information`;
                
                // Format and truncate tone & voice content
                const toneContent = client.tone || 'No tone guidelines set';
                const maxLength = 200;
                
                if (toneContent.length > maxLength) {
                    const truncated = toneContent.substring(0, maxLength).trim();
                    const lastSpace = truncated.lastIndexOf(' ');
                    const finalTruncated = lastSpace > 0 ? truncated.substring(0, lastSpace) : truncated;
                    
                    clientToneInfo.innerHTML = `
                        <div class="tone-preview">${finalTruncated}...</div>
                        <button type="button" class="edit-tone-btn" onclick="editClientTone('${client.id}')">
                             Edit Tone & Voice
                        </button>
                    `;
                } else {
                    clientToneInfo.innerHTML = `
                        <div class="tone-preview">${toneContent}</div>
                        <button type="button" class="edit-tone-btn" onclick="editClientTone('${client.id}')">
                             Edit Tone & Voice
                        </button>
                    `;
                }
                
                clientArtifactsInfo.textContent = client.aiArtifacts;
                clientLastUpdated.textContent = new Date(client.lastUpdated).toLocaleDateString();
                clientInfo.classList.add('show');
            }
        }

        // Version management
        const APP_VERSION = '1.3.1';
        const VERSION_CHECK_INTERVAL = 300000; // 5 minutes

        // Check for updates
        async function checkForUpdates() {
            try {
                const response = await fetch(`/version.json?t=${Date.now()}`);
                const versionData = await response.json();
                
                if (versionData.version !== APP_VERSION) {
                    showUpdateNotification(versionData);
                }
            } catch (error) {
                console.log('Version check failed:', error);
            }
        }

        // Show update notification
        function showUpdateNotification(versionData) {
            // Remove existing notification
            const existing = document.getElementById('updateNotification');
            if (existing) existing.remove();
            
            const notification = document.createElement('div');
            notification.id = 'updateNotification';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #3b82f6;
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                max-width: 300px;
                font-size: 14px;
            `;
            
            notification.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 8px;">
                     Update Available!
                </div>
                <div style="margin-bottom: 12px;">
                    New version ${versionData.version} is available. 
                    You're currently using v${APP_VERSION}.
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="window.location.reload()" style="
                        background: white; 
                        color: #3b82f6; 
                        border: none; 
                        padding: 6px 12px; 
                        border-radius: 4px; 
                        cursor: pointer;
                        font-size: 12px;
                        font-weight: 600;
                    ">Update Now</button>
                    <button onclick="this.parentElement.parentElement.remove()" style="
                        background: transparent; 
                        color: white; 
                        border: 1px solid white; 
                        padding: 6px 12px; 
                        border-radius: 4px; 
                        cursor: pointer;
                        font-size: 12px;
                    ">Later</button>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Auto-remove after 30 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 30000);
        }

        // Show version info modal
        function showVersionInfo() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 1000;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 20px;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 15px;
                padding: 30px;
                max-width: 600px;
                width: 100%;
                box-shadow: 0 20px 40px rgba(0,0,0,0.3);
                position: relative;
            `;
            
            modalContent.innerHTML = `
                <h2 style="margin: 0 0 20px 0; color: #1f2937;">Version Information</h2>
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 24px; font-weight: 600; color: #3b82f6; margin-bottom: 5px;">
                        v${APP_VERSION}
                    </div>
                    <div style="color: #6b7280; font-size: 14px;">
                        Build Date: ${new Date().toLocaleDateString()}
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <h3 style="color: #1f2937; margin-bottom: 10px;">Recent Updates</h3>
                    <ul style="color: #4b5563; line-height: 1.6; padding-left: 20px;">
                        <li>Fixed AI Artifacts review to use client-specific memory instead of generic list</li>
                        <li>Complete modal system rebuild with unique IDs for reliable element targeting</li>
                        <li>Completely rewrote progress indicator system with direct HTML insertion</li>
                        <li>Fixed progress indicator timing issues in review functions</li>
                        <li>Enhanced step element debugging with detailed DOM inspection</li>
                        <li>Enhanced progress indicator debugging with retry logic</li>
                        <li>Fixed progress indicator timing issues and enhanced debugging</li>
                        <li>Fixed progress indicator visual updates and added versioning system</li>
                        <li>Fixed progress indicators in review modals</li>
                        <li>Added keyword management system</li>
                        <li>Improved client management</li>
                        <li>Enhanced article review features</li>
                    </ul>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <h3 style="color: #1f2937; margin-bottom: 10px;">Features</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; color: #4b5563; font-size: 14px;">
                        <div> AI Content Generation</div>
                        <div> Keyword Management</div>
                        <div> Client Management</div>
                        <div> Article Review</div>
                        <div> Progress Indicators</div>
                        <div> Auto-save</div>
                    </div>
                </div>
                
                <div style="text-align: center;">
                    <button onclick="this.closest('.modal').remove()" style="
                        background: #3b82f6; 
                        color: white; 
                        border: none; 
                        padding: 10px 20px; 
                        border-radius: 6px; 
                        cursor: pointer;
                        font-weight: 600;
                    ">Close</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Close on outside click
            modal.onclick = (e) => {
                if (e.target === modal) modal.remove();
            };
        }

        // Initialize version checking
        document.addEventListener('DOMContentLoaded', function() {
            // Check for updates on load
            setTimeout(checkForUpdates, 2000);
            
            // Check for updates periodically
            setInterval(checkForUpdates, VERSION_CHECK_INTERVAL);
        });
    </script>
</body>
</html>
